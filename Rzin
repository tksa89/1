// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                     ğŸ‡¸ğŸ‡¦ RZIN Harmonic Pro v80.0 | v60 ENGINE FUSION ğŸ‡¸ğŸ‡¦                     â•‘
// â•‘â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•‘
// â•‘                                                                                          â•‘
// â•‘   ğŸ›ï¸ TRIPLE DECOUPLING + SENSORS                                                         â•‘
// â•‘   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                       â•‘
// â•‘   ğŸŸ¡ ENGINE 1 - BC RADAR:    Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø¯Ø®ÙˆÙ„ (PRZ)                                          â•‘
// â•‘   â­ ENGINE 2 - XA ANCHOR:   Ù†Ù‚Ø·Ø© Ø§Ù„ÙƒÙ…Ø§Ù„ (Ideal D)                                       â•‘
// â•‘   ğŸŸ¢ ENGINE 3 - CD HARVEST:  Ø£Ù‡Ø¯Ø§Ù Ø§Ù„Ø±Ø¨Ø­ (TP)                                            â•‘
// â•‘   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                       â•‘
// â•‘   ğŸ”— CONFLUENCE ENGINE + ğŸ”” SMART ALERTS V3                                               â•‘
// â•‘   ğŸ§  PROBABILITY ENGINE + ğŸ“Š QUALITY SCORING                                             â•‘
// â•‘   ğŸ¨ VISION 2030 THEMES: Ø§Ù„Ù…Ø±Ø¨Ø¹ Ø§Ù„Ø¬Ø¯ÙŠØ¯ | Ø±ÙˆØ´Ù† | Ø§Ù„Ø¹Ù„Ø§ | ØªØ±ÙˆØ¬ÙŠÙ†Ø§ | Ø§Ù„Ø¨Ø­Ø± Ø§Ù„Ø£Ø­Ù…Ø± | Ø§Ù„Ù‚Ø¯ÙŠØ©    â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//@version=5
indicator("RZIN Harmonic Pro V2", overlay=true, max_lines_count=400, max_labels_count=400, max_bars_back=5000)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘                              [01] Ø§Ù„Ø«ÙˆØ§Ø¨Øª Ø§Ù„Ø¹Ø§Ù…Ø©                                        â•‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const int MAX_PIV = 60
const int MAX_PAT = 30
const int MAX_BARS = 5000

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘                              [02] Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª â€” International UI                          â•‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€ ğŸš¨ LEGAL SHIELD / Ø§Ù„Ø¯Ø±Ø¹ Ø§Ù„Ù‚Ø§Ù†ÙˆÙ†ÙŠ â”€â”€â”€
string G_LEGAL = "ğŸš¨ Ø¥Ø®Ù„Ø§Ø¡ Ù…Ø³Ø¤ÙˆÙ„ÙŠØ© / Disclaimer"
bool i_AcceptDisclaimer = input.bool(true, "Ø¥Ø®Ù„Ø§Ø¡ Ù…Ø³Ø¤ÙˆÙ„ÙŠØ©: Ù…Ù†Ø¸ÙˆÙ…Ø© RZIN Pro Ù…Ø­Ø±Ùƒ Ø§Ø³ØªØ¯Ù„Ø§Ù„ Ø¨ÙÙ†ÙŠ Ù‡Ù†Ø¯Ø³ÙŠØ§Ù‹ Ù…Ù† Ø§Ù„ØµÙØ± ÙƒØ£Ø¯Ø§Ø© Ù…Ø­Ø§ÙƒØ§Ø© ØªÙ‚Ù†ÙŠØ© Ù„Ø§ ØªÙ‚Ø¯Ù… ØªÙˆØµÙŠØ§Øª Ù…Ø§Ù„ÙŠØ© ÙˆØ¯ÙˆÙ† Ø£Ø¯Ù†Ù‰ Ù…Ø³Ø¤ÙˆÙ„ÙŠØ©\n\nDisclaimer: RZIN Pro is a proprietary technical simulation engine built from scratch. Not financial advice. Use at your own risk\n\nå…è´£å£°æ˜: RZIN Pro ä»é›¶æ„å»ºçš„æŠ€æœ¯æ¨¡æ‹Ÿå¼•æ“ ä¸æä¾›æŠ•èµ„å»ºè®® ä½¿ç”¨è€…è‡ªè¡Œæ‰¿æ‹…è´£ä»»\n\nSorumluluk Reddi: RZIN Pro sÄ±fÄ±rdan inÅŸa edilmiÅŸ teknik simÃ¼lasyon motorudur. Mali tavsiye vermez, sorumluluk kullanÄ±cÄ±ya aittir\n\nĞÑ‚ĞºĞ°Ğ· Ğ¾Ñ‚ Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾ÑÑ‚Ğ¸: RZIN Pro â€” Ñ‚ĞµÑ…Ğ½Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ ÑĞ¸Ğ¼ÑƒĞ»ÑÑ‚Ğ¾Ñ€, Ğ¿Ğ¾ÑÑ‚Ñ€Ğ¾ĞµĞ½Ğ½Ñ‹Ğ¹ Ñ Ğ½ÑƒĞ»Ñ. ĞĞµ ÑĞ²Ğ»ÑĞµÑ‚ÑÑ Ñ„Ğ¸Ğ½Ğ°Ğ½ÑĞ¾Ğ²Ğ¾Ğ¹ Ñ€ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´Ğ°Ñ†Ğ¸ĞµĞ¹", group=G_LEGAL)

// â”€â”€â”€ ğŸŒ IDENTITY / Ø§Ù„Ù‡ÙˆÙŠØ© â”€â”€â”€
string G_VIS = "ğŸŒ Identity / Ø§Ù„Ù‡ÙˆÙŠØ©"
string i_Theme = input.string("Murabba", "ğŸ¨ Theme / Ø§Ù„Ø«ÙŠÙ…", options=["Murabba", "Roshn", "AlUla", "Trojena", "Red Sea", "Qiddiya"], group=G_VIS, tooltip="Ø§Ù„Ù…Ø¸Ù‡Ø± Ø§Ù„Ø¨ØµØ±ÙŠ Ù„Ù„Ù…Ø¤Ø´Ø±\nVisual theme for the indicator")
string i_Lang = input.string("Arabic", "ğŸŒ Language / Ø§Ù„Ù„ØºØ©", options=["Arabic", "English", "Chinese", "Turkish", "Russian"], group=G_VIS, tooltip="Ù„ØºØ© Ø§Ù„ØªÙ†Ø¨ÙŠÙ‡Ø§Øª ÙˆØ§Ù„Ø±Ø³Ø§Ø¦Ù„\nLanguage for alerts & messages")

// â”€â”€â”€ âš™ï¸ SETTINGS / Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª â”€â”€â”€
string G1 = "âš™ï¸ Settings / Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª"
float i_Tol = input.float(5.0, "ğŸ¯ Tolerance / Ø§Ù„ØªØ³Ø§Ù…Ø­ %", minval=1.0, maxval=15.0, step=1.0, group=G1, tooltip="Ù†Ø³Ø¨Ø© Ø§Ù„Ø³Ù…Ø§Ø­ ÙÙŠ Ù…Ø·Ø§Ø¨Ù‚Ø© Ø§Ù„Ù†Ø³Ø¨ Ø§Ù„Ù‡Ø§Ø±Ù…ÙˆÙ†ÙŠÙƒ\nRatio matching tolerance for harmonic patterns") / 100.0
float i_Sensitivity = input.float(3.0, "ğŸ“¡ Sensitivity / Ø§Ù„Ø­Ø³Ø§Ø³ÙŠØ© (ATRÃ—)", minval=1.0, maxval=10.0, step=0.5, group=G1, tooltip="Ø­Ø³Ø§Ø³ÙŠØ© ÙƒØ´Ù Ø§Ù„ØªØ¯Ø§Ø®Ù„ Ø¨ÙŠÙ† Ø§Ù„Ø£Ù†Ù…Ø§Ø·\nOverlap detection sensitivity between patterns")
float i_TimeMultiplier = input.float(1.5, "â±ï¸ Time Stop / Ø¥ÙŠÙ‚Ø§Ù Ø²Ù…Ù†ÙŠ (Ã—AB)", minval=1.0, maxval=3.0, step=0.5, group=G1, tooltip="Ù…Ø¶Ø§Ø¹Ù Ø§Ù„Ù…Ø¯Ø© Ø§Ù„Ø²Ù…Ù†ÙŠØ© Ù„ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ù†Ù…Ø·\nTime multiplier for pattern validity window")

// Ø£Ø¹Ù…Ø§Ù‚ Ù…Ø¯Ù…Ø¬Ø© â€” 8 Ø£Ø¹Ù…Ø§Ù‚ ÙƒØ§Ù…Ù„Ø© (Ù…Ù† Ø§Ù„ØµØºÙŠØ± Ù„Ù„ÙƒØ¨ÙŠØ±)
int d1 = 13
int d2 = 21
int d2b = 28
int d3 = 34
int d4 = 48
int d5b = 55
int d5 = 68
int d6 = 89
int d7 = 127
int d8 = 144

// â”€â”€â”€ Ø£Ø±Ø¶ÙŠØ© span Ù„ÙƒÙ„ Ø¹Ù…Ù‚ â€” Ø¨Ø¯ÙˆÙ† Ø³Ù‚Ù â€” Ø§Ù„Ø¨ØµÙ…Ø© ØªÙ…Ù†Ø¹ Ø§Ù„ØªÙƒØ±Ø§Ø± â”€â”€â”€
int SCAN_DEPTH = 20

f_tierMin(int depth) =>
    depth <= 13 ? 20 : depth <= 21 ? 40 : depth <= 28 ? 55 : depth <= 34 ? 70 : depth <= 48 ? 120 : depth <= 55 ? 160 : depth <= 68 ? 200 : depth <= 89 ? 300 : depth <= 127 ? 500 : 600

// Ø­Ø¯ Ø£Ø¯Ù†Ù‰ Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ â€” ÙŠØªÙƒÙŠÙ Ù…Ø¹ Ø§Ù„ÙØ±ÙŠÙ…

// Dirty flags â€” 10 Ø£Ø¹Ù…Ø§Ù‚
var bool dirty1 = false, var bool dirty2 = false, var bool dirty2b = false, var bool dirty3 = false
var bool dirty4 = false, var bool dirty5b = false, var bool dirty5 = false, var bool dirty6 = false
var bool dirty7 = false, var bool dirty8 = false

// â”€â”€â”€ ğŸ¦‹ PATTERNS / Ø§Ù„Ø£Ù†Ù…Ø§Ø· â”€â”€â”€
string G3 = "ğŸ¦‹ Patterns / Ø§Ù„Ø£Ù†Ù…Ø§Ø·"
bool i_Gartley = input.bool(true, "Gartley / Ø¬Ø§Ø±ØªÙ„ÙŠ", inline="p1", group=G3, tooltip="Ù†Ù…Ø· Ø¬Ø§Ø±ØªÙ„ÙŠ â€” XAB: 0.618 | XAD: 0.786\nGartley pattern â€” XAB: 0.618 | XAD: 0.786")
bool i_Bat = input.bool(true, "Bat / Ø§Ù„Ø®ÙØ§Ø´", inline="p1", group=G3, tooltip="Ù†Ù…Ø· Ø§Ù„Ø®ÙØ§Ø´ â€” XAB: 0.382-0.5 | XAD: 0.886\nBat pattern â€” XAB: 0.382-0.5 | XAD: 0.886")
bool i_AltBat = input.bool(true, "Alt Bat / Ø®ÙØ§Ø´ Ø¨Ø¯ÙŠÙ„", inline="p1", group=G3, tooltip="Ù†Ù…Ø· Ø§Ù„Ø®ÙØ§Ø´ Ø§Ù„Ø¨Ø¯ÙŠÙ„ â€” XAB: 0.382 | XAD: 1.13\nAlternate Bat â€” XAB: 0.382 | XAD: 1.13")
bool i_Butterfly = input.bool(true, "Butterfly / Ø§Ù„ÙØ±Ø§Ø´Ø©", inline="p2", group=G3, tooltip="Ù†Ù…Ø· Ø§Ù„ÙØ±Ø§Ø´Ø© â€” XAB: 0.786 | XAD: 1.27\nButterfly pattern â€” XAB: 0.786 | XAD: 1.27")
bool i_Crab = input.bool(true, "Crab / Ø§Ù„Ø³Ø±Ø·Ø§Ù†", inline="p2", group=G3, tooltip="Ù†Ù…Ø· Ø§Ù„Ø³Ø±Ø·Ø§Ù† â€” XAB: 0.382-0.618 | XAD: 1.618\nCrab pattern â€” XAB: 0.382-0.618 | XAD: 1.618")
bool i_DeepCrab = input.bool(true, "Deep Crab / Ø³Ø±Ø·Ø§Ù† Ø¹Ù…ÙŠÙ‚", inline="p2", group=G3, tooltip="Ù†Ù…Ø· Ø§Ù„Ø³Ø±Ø·Ø§Ù† Ø§Ù„Ø¹Ù…ÙŠÙ‚ â€” XAB: 0.886 | XAD: 1.618\nDeep Crab â€” XAB: 0.886 | XAD: 1.618")
bool i_Shark = input.bool(true, "Shark / Ø§Ù„Ù‚Ø±Ø´", inline="p3", group=G3, tooltip="Ù†Ù…Ø· Ø§Ù„Ù‚Ø±Ø´ â€” XAB: 0.382-0.618 | XAD: 0.886-1.13\nShark pattern â€” XAB: 0.382-0.618 | XAD: 0.886-1.13")

// â”€â”€â”€ ğŸ¯ TARGETS / Ø§Ù„Ø£Ù‡Ø¯Ø§Ù â”€â”€â”€
string G4 = "ğŸ¯ Targets / Ø§Ù„Ø£Ù‡Ø¯Ø§Ù"
bool i_ShowPRZ = input.bool(true, "PRZ (BC) / Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø¯Ø®ÙˆÙ„", inline="t1", group=G4, tooltip="Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø§Ù†Ø¹ÙƒØ§Ø³ Ø§Ù„Ù…Ø­ØªÙ…Ù„Ø© â€” Ù…Ø³ØªÙˆÙŠØ§Øª BC\nPotential Reversal Zone â€” BC levels")
bool i_ShowXA = input.bool(true, "XA Anchor / Ù…Ø±Ø³Ø§Ø© XA", inline="t1", group=G4, tooltip="Ù†Ù‚Ø·Ø© Ø§Ù„ÙƒÙ…Ø§Ù„ Ø§Ù„Ù…Ø«Ø§Ù„ÙŠØ© Ù„Ù€ D\nIdeal D completion point")
bool i_ShowTP = input.bool(true, "TP (CD) / Ø£Ù‡Ø¯Ø§Ù Ø§Ù„Ø±Ø¨Ø­", inline="t1", group=G4, tooltip="Ø£Ù‡Ø¯Ø§Ù Ø§Ù„Ø±Ø¨Ø­ Ù…Ù† Ø§Ù…ØªØ¯Ø§Ø¯ CD\nTake profit targets from CD extension")
float i_TP1_R = input.float(0.382, "TP1 / Ø§Ù„Ù‡Ø¯Ù â‘ ", minval=0.1, maxval=1.0, step=0.05, group=G4, tooltip="Ù†Ø³Ø¨Ø© Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ø£ÙˆÙ„ (Ø§Ø±ØªØ¯Ø§Ø¯ CD)\nFirst target ratio (CD retracement)")
float i_TP2_R = input.float(0.618, "TP2 / Ø§Ù„Ù‡Ø¯Ù â‘¡", minval=0.1, maxval=1.0, step=0.05, group=G4, tooltip="Ù†Ø³Ø¨Ø© Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ø«Ø§Ù†ÙŠ (Ø§Ø±ØªØ¯Ø§Ø¯ CD)\nSecond target ratio (CD retracement)")

// â”€â”€â”€ ğŸ¨ DISPLAY / Ø§Ù„Ø¹Ø±Ø¶ â”€â”€â”€
string G5 = "ğŸ¨ Display / Ø§Ù„Ø¹Ø±Ø¶"
bool i_ShowLabels = input.bool(true, "ğŸ·ï¸ Labels / Ø§Ù„ØªØ³Ù…ÙŠØ§Øª", inline="s1", group=G5, tooltip="Ø¹Ø±Ø¶ ØªØ³Ù…ÙŠØ§Øª X A B C D Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø±Øª\nShow X A B C D labels on chart")
int i_MaxPat = input.int(10, "ğŸ“Š Max Patterns / Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰", minval=1, maxval=20, group=G5, tooltip="Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ù…Ø¹Ø±ÙˆØ¶Ø©\nMaximum displayed patterns")
bool i_MasterHUD = input.bool(true, "ğŸ–¥ï¸ Master HUD / Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…", group=G5, tooltip="ØªØ´ØºÙŠÙ„/Ø¥ÙŠÙ‚Ø§Ù Ù„ÙˆØ­Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ÙˆØ­Ø¯Ø©\nMaster switch for the unified dashboard")

// â”€â”€â”€ ğŸ‘» GHOST SENSORS / Ù…Ø³ØªØ´Ø¹Ø±Ø§Øª Ø§Ù„Ø£Ø´Ø¨Ø§Ø­ â”€â”€â”€
string G5B = "ğŸ‘» Ghost Sensors / Ù…Ø³ØªØ´Ø¹Ø±Ø§Øª Ø§Ù„Ø£Ø´Ø¨Ø§Ø­"
bool i_EnableSensors = input.bool(true, "ğŸ”® Enable / ØªÙØ¹ÙŠÙ„", group=G5B, tooltip="ØªÙØ¹ÙŠÙ„ Ù…Ø³ØªØ´Ø¹Ø±Ø§Øª Ø¬ÙˆØ¯Ø© Ø§Ù„Ø£Ø´Ø¨Ø§Ø­ (Ø­Ø¬Ù…ØŒ Ø²Ø®Ù…ØŒ RSI)\nEnable ghost quality sensors (volume, momentum, RSI)")
float i_VolMultiplier = input.float(2.0, "ğŸ“Š Volume / Ø§Ù„Ø­Ø¬Ù… (Ã—Avg)", minval=1.0, maxval=5.0, step=0.5, group=G5B, tooltip="Ù…Ø¶Ø§Ø¹Ù Ø§Ù„Ø­Ø¬Ù… â€” Ø£Ù‚Ù„ = Ø£ÙƒØ«Ø± Ø­Ø³Ø§Ø³ÙŠØ©\nVolume multiplier â€” lower = more sensitive")
float i_ZScoreMin = input.float(1.5, "âš¡ Tension / Ø§Ù„ØªÙˆØªØ± (Z-Score)", minval=0.5, maxval=3.0, step=0.5, group=G5B, tooltip="Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ù„Ø§Ù†Ø­Ø±Ø§Ù Ø§Ù„Ù…Ø¹ÙŠØ§Ø±ÙŠ Ù„Ù„ÙƒØ´Ù Ø¹Ù† Ø§Ù„ØªÙˆØªØ± Ø§Ù„Ø³Ø¹Ø±ÙŠ\nMinimum standard deviation for price tension detection")
int i_RSIPeriod = input.int(14, "ğŸ“ˆ RSI Period / ÙØªØ±Ø© RSI", minval=5, maxval=30, group=G5B, tooltip="ÙØªØ±Ø© Ø­Ø³Ø§Ø¨ Ù…Ø¤Ø´Ø± Ø§Ù„Ù‚ÙˆØ© Ø§Ù„Ù†Ø³Ø¨ÙŠØ©\nRelative Strength Index calculation period")

// â”€â”€â”€ ğŸ”” ALERTS / Ø§Ù„ØªÙ†Ø¨ÙŠÙ‡Ø§Øª â”€â”€â”€
string G8 = "ğŸ”” Alerts / Ø§Ù„ØªÙ†Ø¨ÙŠÙ‡Ø§Øª"
bool i_EnableAlerts = input.bool(true, "ğŸ”” Smart Alerts V3 / ØªÙ†Ø¨ÙŠÙ‡Ø§Øª Ø°ÙƒÙŠØ©", group=G8, tooltip="ØªÙØ¹ÙŠÙ„ ØªÙ‚Ø§Ø±ÙŠØ± Ø§Ø³ØªØ®Ø¨Ø§Ø±Ø§ØªÙŠØ©: Ù…ÙƒØªÙ…Ù„ØŒ Ù‚Ø·Ø§Ø¹ÙŠØŒ Ø³ÙŠÙˆÙ„Ø©ØŒ Ø§Ø³ØªØ¨Ø§Ù‚ÙŠØŒ Ù‡Ø¯ÙØŒ Ø­Ù…Ø§ÙŠØ©\nEnable intelligence reports: complete, sector, volume, ghost, target, protection")
int i_QualityMin = input.int(50, "ğŸ“Š Min Quality / Ø¬ÙˆØ¯Ø© Ø£Ø¯Ù†Ù‰ %", minval=0, maxval=90, step=10, group=G8, tooltip="Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ Ù„Ø¬ÙˆØ¯Ø© Ø§Ù„Ù†Ù…Ø· Ù„Ø¥Ø±Ø³Ø§Ù„ ØªÙ†Ø¨ÙŠÙ‡ ÙƒØ§Ù…Ù„\nMinimum pattern quality for full alert report")


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘              ğŸ“¡ RZIN COMMAND CENTER â€” Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª                                            â•‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
string G_U1 = "1ï¸âƒ£ Ø±Ø§Ø¯Ø§Ø± Ø§Ù„Ø³ÙŠÙˆÙ„Ø© / Liquidity"
bool u_liq = input.bool(true, "Ø§Ù„ÙƒØ±ÙŠØ¨ØªÙˆ (BTC|ETH|Ù‡ÙŠÙ…Ù†Ø©|Ø³ÙŠÙˆÙ„Ø©|SSR)", group=G_U1)
string G_U2 = "2ï¸âƒ£ Ø§Ù„Ø¹Ù…Ø§Ù„Ù‚Ø© / Titans"
bool u_titans = input.bool(true, "Ø§Ù„Ø¹Ù…Ø§Ù„Ù‚Ø© (Elon|Saylor|BRock|Exch)", group=G_U2)
string G_U3 = "3ï¸âƒ£ Ø§Ù„Ù‚Ø·Ø§Ø¹Ø§Øª / Sectors"
bool u_sectors = input.bool(true, "Ø§Ù„Ù‚Ø·Ø§Ø¹Ø§Øª (AI|L1|Meme|RWA|DeFi|L2|Orac|Game)", group=G_U3)
string G_U4 = "4ï¸âƒ£ Ø§Ù„Ù…Ø§ÙƒØ±Ùˆ / Macro"
bool u_macro = input.bool(true, "Ø§Ù„Ù…Ø§ÙƒØ±Ùˆ (VIX|DXY|Gold|DJI|TASI)", group=G_U4)
string G_U6 = "6ï¸âƒ£ Ø§Ù„Ø³ÙŠØ§Ø¯Ø© / Sovereignty"
bool u_sov = input.bool(true, "Ø§Ù„Ø³ÙŠØ§Ø¯Ø© (FED|Rate)", group=G_U6)
string G_U9 = "9ï¸âƒ£ Ø§Ù„Ù†ÙØ· / Oil"
bool u_oil = input.bool(true, "Ø§Ù„Ù†ÙØ· (Brent|WTI)", group=G_U9)
string G_SYS = "ğŸ”§ Ø§Ù„Ù†Ø¸Ø§Ù… / System"
bool u_sys = input.bool(true, "Ø§Ù„Ù†Ø¸Ø§Ù… (EVENT|SAFETY)", group=G_SYS)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘              ğŸ¨ THEME ENGINE â€” Addictive Vision 2030 Palettes                            â•‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
color T_BULL    = #00E676
color T_BEAR    = #FF1744
color T_GHOST   = #9E9E9E
color T_LSR     = #E0E0E0
color T_LABELS  = #BB86FC
color T_PRZ     = #D4AF37
color T_XA      = #00BCD4
color T_TP      = #00E676

// 1ï¸âƒ£ Murabba â€” Electric Luxury
if i_Theme == "Murabba"
    T_BULL := #00E676, T_BEAR := #FF1744, T_GHOST := #B0BEC5
    T_LSR := #CFD8DC, T_LABELS := #BB86FC
    T_PRZ := #FFD740, T_XA := #18FFFF, T_TP := #69F0AE
// 2ï¸âƒ£ Roshn â€” Heritage Gold
else if i_Theme == "Roshn"
    T_BULL := #66BB6A, T_BEAR := #EF5350, T_GHOST := #A1887F
    T_LSR := #BCAAA4, T_LABELS := #FFE0B2
    T_PRZ := #FFB300, T_XA := #8D6E63, T_TP := #43A047
// 3ï¸âƒ£ AlUla â€” Sandstone Glow
else if i_Theme == "AlUla"
    T_BULL := #AED581, T_BEAR := #FF7043, T_GHOST := #BCAAA4
    T_LSR := #D7CCC8, T_LABELS := #FFB74D
    T_PRZ := #FF8F00, T_XA := #D7CCC8, T_TP := #FFE082
// 4ï¸âƒ£ Trojena â€” Ice Blade
else if i_Theme == "Trojena"
    T_BULL := #40C4FF, T_BEAR := #FF5252, T_GHOST := #B0BEC5
    T_LSR := #E1F5FE, T_LABELS := #E0E0E0
    T_PRZ := #448AFF, T_XA := #80D8FF, T_TP := #0091EA
// 5ï¸âƒ£ Red Sea â€” Coral Reef
else if i_Theme == "Red Sea"
    T_BULL := #26A69A, T_BEAR := #FF8A65, T_GHOST := #80CBC4
    T_LSR := #B2DFDB, T_LABELS := #4DD0E1
    T_PRZ := #FFAB91, T_XA := #80CBC4, T_TP := #00BFA5
// 6ï¸âƒ£ Qiddiya â€” Neon Rush
else if i_Theme == "Qiddiya"
    T_BULL := #76FF03, T_BEAR := #FF3D00, T_GHOST := #FFD54F
    T_LSR := #FFF9C4, T_LABELS := #EEFF41
    T_PRZ := #FFAB00, T_XA := #FF6D00, T_TP := #FF3D00

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘                              [03] Ø§Ù„Ø£Ù†ÙˆØ§Ø¹                                               â•‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
type Pivot
    float price
    int bar
    int dir

type Pattern
    string name
    bool isBull
    float score
    float pX
    float pA
    float pB
    float pC
    float pD
    int bX
    int bA
    int bB
    int bC
    int bD
    bool isGhost
    int timeLimit       // Ù…Ø­Ø¬ÙˆØ² â€” ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡ Ù„Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„Ø£Ø´Ø¨Ø§Ø­ Ù…Ø³ØªÙ‚Ø¨Ù„Ø§Ù‹
    int confluence
    float rXAB          // metadata â€” Ø§Ù„Ù†Ø³Ø¨ Ù…Ø­ÙÙˆØ¸Ø© Ù„Ù„Ø¹Ø±Ø¶/Ø§Ù„ØªØµØ¯ÙŠØ±
    float rABC          // metadata
    float rXAD          // metadata
    bool alertedNew = false
    bool alertedTP1 = false
    bool alertedTP2 = false
    bool alertedSL  = false

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘                              [04] Ø§Ù„Ù…ØµÙÙˆÙØ§Øª                                             â•‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var array<Pivot> pv1 = array.new<Pivot>()
var array<Pivot> pv2 = array.new<Pivot>()
var array<Pivot> pv2b = array.new<Pivot>()
var array<Pivot> pv3 = array.new<Pivot>()
var array<Pivot> pv4 = array.new<Pivot>()
var array<Pivot> pv5b = array.new<Pivot>()
var array<Pivot> pv5 = array.new<Pivot>()
var array<Pivot> pv6 = array.new<Pivot>()
var array<Pivot> pv7 = array.new<Pivot>()
var array<Pivot> pv8 = array.new<Pivot>()
var array<Pattern> patterns = array.new<Pattern>()
var array<line> gLines = array.new_line()
var array<label> gLabels = array.new_label()
// â”€â”€â”€ Level Dedup â€” Ù…Ù†Ø¹ ØªÙƒØ±Ø§Ø± Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„Ù…ØªÙ‚Ø§Ø±Ø¨Ø© â”€â”€â”€
var array<float> drawnLvls = array.new_float()
f_lvlNew(float lvl) =>
    bool isNew = true
    int dlSz = array.size(drawnLvls)
    if dlSz > 0
        for j = 0 to dlSz - 1
            float ex = array.get(drawnLvls, j)
            if ex > 0
                if math.abs(lvl - ex) / ex < 0.02
                    isNew := false
    isNew

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘                              [05] Ø§Ù„Ù…Ø¤Ø´Ø±Ø§Øª                                              â•‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
float atrVal = ta.atr(14)
float ph1 = ta.pivothigh(high, d1, d1), float pl1 = ta.pivotlow(low, d1, d1)
float ph2 = ta.pivothigh(high, d2, d2), float pl2 = ta.pivotlow(low, d2, d2)
float ph2b = ta.pivothigh(high, d2b, d2b), float pl2b = ta.pivotlow(low, d2b, d2b)
float ph3 = ta.pivothigh(high, d3, d3), float pl3 = ta.pivotlow(low, d3, d3)
float ph4 = ta.pivothigh(high, d4, d4), float pl4 = ta.pivotlow(low, d4, d4)
float ph5b = ta.pivothigh(high, d5b, d5b), float pl5b = ta.pivotlow(low, d5b, d5b)
float ph5 = ta.pivothigh(high, d5, d5), float pl5 = ta.pivotlow(low, d5, d5)
float ph6 = ta.pivothigh(high, d6, d6), float pl6 = ta.pivotlow(low, d6, d6)
float ph7 = ta.pivothigh(high, d7, d7), float pl7 = ta.pivotlow(low, d7, d7)
float ph8 = ta.pivothigh(high, d8, d8), float pl8 = ta.pivotlow(low, d8, d8)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘                              [06] ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø­Ø§ÙˆØ±                                         â•‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
updatePivots(array<Pivot> arr, float ph, float pl, int depth) =>
    int b = bar_index - depth
    if not na(ph)
        int sz = array.size(arr)
        if sz == 0
            array.unshift(arr, Pivot.new(ph, b, 1))
        else
            Pivot last = array.get(arr, 0)
            if last.dir == 1
                if ph > last.price
                    array.set(arr, 0, Pivot.new(ph, b, 1))
            else
                array.unshift(arr, Pivot.new(ph, b, 1))
    if not na(pl)
        int sz = array.size(arr)
        if sz == 0
            array.unshift(arr, Pivot.new(pl, b, -1))
        else
            Pivot last = array.get(arr, 0)
            if last.dir == -1
                if pl < last.price
                    array.set(arr, 0, Pivot.new(pl, b, -1))
            else
                array.unshift(arr, Pivot.new(pl, b, -1))
    while array.size(arr) > MAX_PIV
        array.pop(arr)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘                              [07] Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø©                                           â•‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
inRange(float v, float mn, float mx, float tol) =>
    v >= mn * (1.0 - tol) and v <= mx * (1.0 + tol)

f_bcEnvelope(string name, float pB, float pC, float pD, float tol) =>
    float bcMin = 0.0, float bcMax = 0.0
    if name == "Gartley"
        bcMin := 1.13, bcMax := 1.618
    else if name == "Bat"
        bcMin := 1.618, bcMax := 2.618
    else if name == "Alt Bat"
        bcMin := 2.0, bcMax := 3.618
    else if name == "Butterfly"
        bcMin := 1.618, bcMax := 2.618
    else if name == "Crab"
        bcMin := 2.618, bcMax := 3.618
    else if name == "Deep Crab"
        bcMin := 2.0, bcMax := 3.618
    else if name == "Shark"
        bcMin := 1.618, bcMax := 2.24
    float bc = math.abs(pC - pB)
    float cd = math.abs(pD - pC)
    float rBCD = bc > 0 ? cd / bc : 0.0
    rBCD >= bcMin * (1.0 - tol) and rBCD <= bcMax * (1.0 + tol)

f_legOk(array<Pivot> arr, int i1, int i2, float p1, float p2) =>
    bool ok = true
    float lo = math.min(p1, p2)
    float hi = math.max(p1, p2)
    if i2 > i1 + 1
        for k = i1 + 1 to i2 - 1
            Pivot sk = array.get(arr, k)
            if sk.price < lo or sk.price > hi
                ok := false
    ok

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                    ğŸ›ï¸ TRIPLE DECOUPLING ENGINES (v60 Logic) ğŸ›ï¸                            â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘              ğŸŸ¡ ENGINE 1: BC RADAR â€” Ù†Ø³Ø¨ D=BC Ø§Ù„Ù…ÙˆØ­Ø¯Ø© Ù…Ù† Ø§Ù„Ù…Ø±Ø¬Ø¹ Ø§Ù„Ù…Ø¹ØªÙ…Ø¯                  â•‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
get_BC_Ratios(string name) =>
    array<float> r = array.new_float()
    if name == "Gartley"
        array.push(r, 1.13), array.push(r, 1.27), array.push(r, 1.618)
    else if name == "Bat"
        array.push(r, 1.618), array.push(r, 2.0), array.push(r, 2.24), array.push(r, 2.618)
    else if name == "Alt Bat"
        array.push(r, 2.0), array.push(r, 2.24), array.push(r, 2.618), array.push(r, 3.0), array.push(r, 3.618)
    else if name == "Butterfly"
        array.push(r, 1.618), array.push(r, 2.0), array.push(r, 2.24), array.push(r, 2.618)
    else if name == "Crab"
        array.push(r, 2.618), array.push(r, 3.14), array.push(r, 3.618)
    else if name == "Deep Crab"
        array.push(r, 2.0), array.push(r, 2.24), array.push(r, 2.618), array.push(r, 3.0), array.push(r, 3.618)
    else if name == "Shark"
        array.push(r, 1.618), array.push(r, 2.0), array.push(r, 2.24)
    r

// â”€â”€â”€ Ø­Ø³Ø§Ø¨ Ù…Ø³ØªÙˆÙŠØ§Øª BC (Logarithmic Math) â”€â”€â”€
// Log projection: level = C Ã— (B/C)^ratio
// Ù‡Ø°Ø§ ÙŠØ­Ø³Ø¨ Ø§Ù„Ø§Ù…ØªØ¯Ø§Ø¯ Ø¨Ø´ÙƒÙ„ Ù†Ø³Ø¨ÙŠ ÙˆÙ„ÙŠØ³ Ø®Ø·ÙŠ
calc_BC_Levels(string name, float pB, float pC) =>
    array<float> ratios = get_BC_Ratios(name)
    array<float> levels = array.new_float()
    int sz = array.size(ratios)
    if sz > 0 and pB > 0 and pC > 0
        float logB = math.log(pB)
        float logC = math.log(pC)
        float logBC = logC - logB
        for i = 0 to sz - 1
            float rat = array.get(ratios, i)
            // Log projection: Ù…Ù† C Ø¨Ø¹ÙƒØ³ Ø§ØªØ¬Ø§Ù‡ BC
            float logLevel = logC - (logBC * rat)
            array.push(levels, math.exp(logLevel))
    [levels, ratios]

// â”€â”€â”€ Dynamic Bracketing (v60) â€” Ø§Ù„Ù†Ø³Ø¨ØªÙŠÙ† Ø§Ù„Ù…Ø­ÙŠØ·ØªÙŠÙ† Ø¨Ø§Ù„Ø³Ø¹Ø± â”€â”€â”€
find_Bracket_Levels(array<float> levels, array<float> ratios, float refPrice, bool isBull) =>
    float upperLvl = na, float lowerLvl = na
    float upperRat = na, float lowerRat = na
    float closestLvl = na, float closestRat = na
    int sz = array.size(levels)
    if sz > 0
        int upperIdx = -1, int lowerIdx = -1
        float upperDist = 999999999.0, float lowerDist = 999999999.0
        for i = 0 to sz - 1
            float lvl = array.get(levels, i)
            float dist = math.abs(lvl - refPrice)
            if lvl >= refPrice
                if dist < upperDist
                    upperDist := dist
                    upperIdx := i
            else
                if dist < lowerDist
                    lowerDist := dist
                    lowerIdx := i
        if upperIdx >= 0
            upperLvl := array.get(levels, upperIdx)
            upperRat := array.get(ratios, upperIdx)
        if lowerIdx >= 0
            lowerLvl := array.get(levels, lowerIdx)
            lowerRat := array.get(ratios, lowerIdx)
        if na(upperLvl) and na(lowerLvl) and sz >= 2
            upperLvl := array.get(levels, sz - 2)
            upperRat := array.get(ratios, sz - 2)
            lowerLvl := array.get(levels, sz - 1)
            lowerRat := array.get(ratios, sz - 1)
        closestLvl := isBull ? lowerLvl : upperLvl
        closestRat := isBull ? lowerRat : upperRat
    [upperLvl, upperRat, lowerLvl, lowerRat, closestLvl, closestRat]

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘              â­ ENGINE 2: XA ANCHOR â€” Smart Multi-Level (Logarithmic)                   â•‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ÙƒÙ„ Ù†Ø³Ø¨ D=XA Ù…Ù† Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù‡Ø§Ø¬Ø±ÙŠ â€” ØªÙØ¹Ø±Ø¶ ÙƒÙ…Ø³ØªÙˆÙŠØ§Øª Ø°ÙƒÙŠØ© Ù…Ø«Ù„ BC
get_XA_Ratios(string name) =>
    array<float> r = array.new_float()
    if name == "Gartley"
        array.push(r, 0.78), array.push(r, 0.886)
    else if name == "Bat"
        array.push(r, 0.886)
    else if name == "Alt Bat"
        array.push(r, 1.13)
    else if name == "Butterfly"
        array.push(r, 1.27)
    else if name == "Crab"
        array.push(r, 1.618), array.push(r, 1.902)
    else if name == "Deep Crab"
        array.push(r, 1.618), array.push(r, 1.902)
    else if name == "Shark"
        array.push(r, 0.886), array.push(r, 1.13)
    r

calc_XA_Levels(string name, float pX, float pA, bool isBull) =>
    array<float> ratios = get_XA_Ratios(name)
    array<float> levels = array.new_float()
    int sz = array.size(ratios)
    if sz > 0 and pX > 0 and pA > 0
        float logX = math.log(pX)
        float logA = math.log(pA)
        float logXA = math.abs(logA - logX)
        for i = 0 to sz - 1
            float rat = array.get(ratios, i)
            float logD = isBull ? logA - (logXA * rat) : logA + (logXA * rat)
            array.push(levels, math.exp(logD))
    [levels, ratios]

// Ù„Ù„ØªÙˆØ§ÙÙ‚ Ù…Ø¹ Ghost targetD â€” ÙŠØ£Ø®Ø° Ø£ÙˆÙ„ Ù†Ø³Ø¨Ø© ÙƒØ§ÙØªØ±Ø§Ø¶ÙŠ
calc_XA_Anchor(string name, float pX, float pA, bool isBull) =>
    [levels, ratios] = calc_XA_Levels(name, pX, pA, isBull)
    float targetD = array.size(levels) > 0 ? array.get(levels, 0) : na
    float ratio = array.size(ratios) > 0 ? array.get(ratios, 0) : na
    [targetD, ratio]

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘              ğŸŸ¢ ENGINE 3: CD HARVEST â€” Logarithmic TP                                   â•‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
calc_TP_Levels(float pC, float pD, float r1, float r2) =>
    float tp1 = na, float tp2 = na
    if pC > 0 and pD > 0
        float logC = math.log(pC)
        float logD = math.log(pD)
        float logCD = logD - logC
        tp1 := math.exp(logD - (logCD * r1))
        tp2 := math.exp(logD - (logCD * r2))
    [tp1, tp2]

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘              ğŸ¯ GHOST SENSORS â€” Pre-computed (global scope, no warnings)                â•‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var float rsiVal = na
rsiVal := ta.rsi(close, i_RSIPeriod)

// ÙƒÙ„ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª ÙÙŠ global scope â€” ØªÙÙ†ÙÙ‘Ø° ÙƒÙ„ Ø¨Ø§Ø± Ø¨Ø¯ÙˆÙ† Ø´Ø±ÙˆØ·
float _gq_avgVol = ta.sma(volume, 10)
float _gq_mean   = ta.sma(close, 20)
float _gq_stdDev = ta.stdev(close, 20)
float _gq_zScore = _gq_stdDev > 0 ? (close - _gq_mean) / _gq_stdDev : 0.0
bool  _gq_volOk  = volume <= (_gq_avgVol * i_VolMultiplier)

// ğŸ§  Ù…Ø¤Ø´Ø±Ø§Øª Ù…Ø­Ø±Ùƒ Ø§Ù„Ø§Ø­ØªÙ…Ø§Ù„Ø§Øª â€” global scope
float ema200   = ta.ema(close, 200)
float volSma20 = ta.sma(volume, 20)

// â”€â”€â”€ Pattern Display Names â€” ØªØ±Ø¬Ù…Ø© Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø£Ù†Ù…Ø§Ø· â”€â”€â”€
f_patName(string n) =>
    if i_Lang == "Arabic"
        n == "Gartley" ? "Ø¬Ø§Ø±ØªÙ„ÙŠ" : n == "Bat" ? "Ø§Ù„Ø®ÙØ§Ø´" : n == "Alt Bat" ? "Ø®ÙØ§Ø´ Ø¨Ø¯ÙŠÙ„" : n == "Butterfly" ? "Ø§Ù„ÙØ±Ø§Ø´Ø©" : n == "Crab" ? "Ø§Ù„Ø³Ø±Ø·Ø§Ù†" : n == "Deep Crab" ? "Ø³Ø±Ø·Ø§Ù† Ø¹Ù…ÙŠÙ‚" : n == "Shark" ? "Ø§Ù„Ù‚Ø±Ø´" : n
    else if i_Lang == "Chinese"
        n == "Gartley" ? "ä¼½ç‰¹åˆ©" : n == "Bat" ? "è™è " : n == "Alt Bat" ? "å˜è " : n == "Butterfly" ? "è´è¶" : n == "Crab" ? "èƒèŸ¹" : n == "Deep Crab" ? "æ·±èŸ¹" : n == "Shark" ? "é²¨é±¼" : n
    else if i_Lang == "Turkish"
        n == "Gartley" ? "Gartley" : n == "Bat" ? "Yarasa" : n == "Alt Bat" ? "Alt Yarasa" : n == "Butterfly" ? "Kelebek" : n == "Crab" ? "YengeÃ§" : n == "Deep Crab" ? "Derin YengeÃ§" : n == "Shark" ? "KÃ¶pekbalÄ±ÄŸÄ±" : n
    else if i_Lang == "Russian"
        n == "Gartley" ? "Ğ“Ğ°Ñ€Ñ‚Ğ»Ğ¸" : n == "Bat" ? "Ğ›ĞµÑ‚ÑƒÑ‡Ğ°Ñ Ğ¼Ñ‹ÑˆÑŒ" : n == "Alt Bat" ? "ĞĞ»ÑŒÑ‚ Ğ‘Ğ°Ñ‚" : n == "Butterfly" ? "Ğ‘Ğ°Ğ±Ğ¾Ñ‡ĞºĞ°" : n == "Crab" ? "ĞšÑ€Ğ°Ğ±" : n == "Deep Crab" ? "Ğ“Ğ»ÑƒĞ±. ĞšÑ€Ğ°Ğ±" : n == "Shark" ? "ĞĞºÑƒĞ»Ğ°" : n
    else
        n

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘                              [09] Ù†Ø³Ø¨ Ø§Ù„Ù‡Ø§Ø¬Ø±ÙŠ                                           â•‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
getBRange(string n) =>
    float bMin = 0.0, float bMax = 0.0
    if n == "Gartley"
        bMin := 0.588, bMax := 0.648
    else if n == "Bat"
        bMin := 0.382, bMax := 0.55
    else if n == "Alt Bat"
        bMin := 0.352, bMax := 0.382
    else if n == "Butterfly"
        bMin := 0.755, bMax := 0.816
    else if n == "Crab"
        bMin := 0.382, bMax := 0.618
    else if n == "Deep Crab"
        bMin := 0.886, bMax := 0.936
    else if n == "Shark"
        bMin := 0.382, bMax := 0.618
    [bMin, bMax]

getCRange(string n) =>
    float cMin = 0.382, float cMax = 0.886
    if n == "Gartley"
        cMin := 0.382, cMax := 0.886
    else if n == "Bat"
        cMin := 0.382, cMax := 0.886
    else if n == "Alt Bat"
        cMin := 0.382, cMax := 0.886
    else if n == "Butterfly"
        cMin := 0.382, cMax := 0.886
    else if n == "Crab"
        cMin := 0.382, cMax := 0.886
    else if n == "Deep Crab"
        cMin := 0.886, cMax := 0.886
    else if n == "Shark"
        cMin := 1.130, cMax := 1.618
    [cMin, cMax]

getDRange(string n) =>
    float dMin = 0.0, float dMax = 0.0
    if n == "Gartley"
        dMin := 0.78, dMax := 0.886
    else if n == "Bat"
        dMin := 0.886, dMax := 0.886
    else if n == "Alt Bat"
        dMin := 1.13, dMax := 1.13
    else if n == "Butterfly"
        dMin := 1.27, dMax := 1.27
    else if n == "Crab"
        dMin := 1.618, dMax := 1.902
    else if n == "Deep Crab"
        dMin := 1.618, dMax := 1.902
    else if n == "Shark"
        dMin := 0.886, dMax := 1.13
    [dMin, dMax]

calcScore(string n, float rXAB, float rXAD, int bX, int bA, int bB, int bC) =>
    [bMin, bMax] = getBRange(n)
    float idealB = (bMin + bMax) / 2.0
    float bError = idealB > 0.0 ? math.abs(rXAB - idealB) / idealB : 0.0
    float bScore = math.max(0.0, 100.0 - bError * 100.0) * 0.40
    [dMin, dMax] = getDRange(n)
    float idealD = (dMin + dMax) / 2.0
    float dError = idealD > 0.0 ? math.abs(rXAD - idealD) / idealD : 0.0
    float dScore = math.max(0.0, 100.0 - dError * 100.0) * 0.40
    int abBars = math.abs(bB - bA)
    int bcBars = math.abs(bC - bB)
    float timeSym = (abBars > 0 and bcBars > 0) ? math.min(float(bcBars) / float(abBars), float(abBars) / float(bcBars)) : 0.0
    bScore + dScore + timeSym * 100.0 * 0.20

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘              ğŸ§  PROBABILITY ENGINE â€” Ù…Ø­Ø±Ùƒ Ø§Ù„Ø§Ø­ØªÙ…Ø§Ù„Ø§Øª (5 Ø¹ÙˆØ§Ù…Ù„ Ù…Ø±Ø¬Ù‘Ø­Ø©)                   â•‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// W1: Ø¯Ù‚Ø© Ø§Ù„Ù†Ø³Ø¨ 30% | W2: Ø§Ù„Ø³ÙŠÙˆÙ„Ø© 20% | W3: RSI Divergence 20%
// W4: Ø§Ù„ØªÙˆØ§ÙÙ‚ Ø§Ù„Ø²Ù…Ù†ÙŠ 15% | W5: Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø¹Ø§Ù… 15%
f_qualityScore(string patName, bool isBull, float rXAB, float rABC, float rXAD, int bX, int bA, int bB, int bC, int bD, float pX, float pD) =>
    // â”€â”€â”€ W1: Ø¯Ù‚Ø© Ø§Ù„Ù†Ø³Ø¨ (30%) â”€â”€â”€
    [bMin, bMax] = getBRange(patName)
    float idealB = (bMin + bMax) / 2.0
    float bErr = idealB > 0 ? math.abs(rXAB - idealB) / idealB : 1.0
    [dMin, dMax] = getDRange(patName)
    float idealD = (dMin + dMax) / 2.0
    float dErr = idealD > 0 ? math.abs(rXAD - idealD) / idealD : 1.0
    [cMin, cMax] = getCRange(patName)
    float idealC = (cMin + cMax) / 2.0
    float cErr = idealC > 0 ? math.abs(rABC - idealC) / idealC : 1.0
    float avgErr = (bErr + dErr + cErr) / 3.0
    float w1 = math.max(0.0, 1.0 - avgErr * 2.0) * 30.0
    // â”€â”€â”€ W2: Ø§Ù„Ø³ÙŠÙˆÙ„Ø© Ø¹Ù†Ø¯ D (20%) â”€â”€â”€
    int dLb = math.max(0, math.min(bar_index - bD, 4999))
    float vAtD = volume[dLb]
    float vAvg = volSma20[dLb]
    float vRat = vAvg > 0 ? vAtD / vAvg : 1.0
    float w2 = vRat >= 2.0 ? 20.0 : vRat >= 1.5 ? 15.0 : vRat >= 1.0 ? 10.0 : 5.0
    // â”€â”€â”€ W3: RSI Divergence (20%) â”€â”€â”€
    int xLb = math.max(0, math.min(bar_index - bX, 4999))
    float rsiD = rsiVal[dLb]
    float rsiX = rsiVal[xLb]
    bool hasDiv = isBull ? (pD <= pX and rsiD > rsiX) : (pD >= pX and rsiD < rsiX)
    float w3 = hasDiv ? 20.0 : 0.0
    // â”€â”€â”€ W4: Ø§Ù„ØªÙˆØ§ÙÙ‚ Ø§Ù„Ø²Ù…Ù†ÙŠ CD vs XA (15%) â”€â”€â”€
    int xaDur = math.abs(bA - bX)
    int cdDur = math.abs(bD - bC)
    float tRat = (xaDur > 0 and cdDur > 0) ? math.min(float(cdDur) / float(xaDur), float(xaDur) / float(cdDur)) : 0.0
    float w4 = tRat * 15.0
    // â”€â”€â”€ W5: Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø¹Ø§Ù… EMA(200) (15%) â”€â”€â”€
    float emaD = ema200[dLb]
    bool trendOk = isBull ? (pD < emaD or close > emaD) : (pD > emaD or close < emaD)
    float w5 = trendOk ? 15.0 : 0.0
    // â”€â”€â”€ Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹ â”€â”€â”€
    int totalQ = int(math.round(w1 + w2 + w3 + w4 + w5))
    [totalQ, hasDiv, vRat >= 1.5, trendOk]

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘              [11] ÙÙ„ØªØ± Ø§Ù„ØªØ¯Ø§Ø®Ù„ + CONFLUENCE                                             â•‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
findOverlap(float pD, bool isBull, string patName, float atr, float sensitivity, int bX, int bA, float pX, float pA, bool isGhostNew, int bB, int bC, float pB, float pC) =>
    int idx = -1
    float bestScore = 0.0
    bool exactMatch = false
    int sz = array.size(patterns)
    float pTol = 0.005
    if sz > 0
        for i = 0 to sz - 1
            if not exactMatch
                Pattern p = array.get(patterns, i)
                if p.isBull == isBull and p.name == patName and p.bX == bX and p.bA == bA
                    exactMatch := true
                    idx := i
                    bestScore := p.score
                else if not exactMatch and p.isBull == isBull and p.name == patName and p.bB == bB and p.bC == bC
                    if idx == -1 or p.score > bestScore
                        idx := i
                        bestScore := p.score
                else if not exactMatch and p.isBull == isBull and p.name == patName
                    bool xP = pX > 0 ? math.abs(p.pX - pX) / pX <= pTol : false
                    bool aP = pA > 0 ? math.abs(p.pA - pA) / pA <= pTol : false
                    bool bP = pB > 0 ? math.abs(p.pB - pB) / pB <= pTol : false
                    bool cP = pC > 0 ? math.abs(p.pC - pC) / pC <= pTol : false
                    if xP and aP and bP and cP
                        if idx == -1 or p.score > bestScore
                            idx := i
                            bestScore := p.score
    [idx, bestScore, exactMatch]

addPattern(Pattern newP, float atr, float sensitivity) =>
    [overlapIdx, existingScore, isExact] = findOverlap(newP.pD, newP.isBull, newP.name, atr, sensitivity, newP.bX, newP.bA, newP.pX, newP.pA, newP.isGhost, newP.bB, newP.bC, newP.pB, newP.pC)
    if overlapIdx >= 0
        Pattern existing = array.get(patterns, overlapIdx)
        // â”€â”€â”€ Ø£ÙˆÙ„ÙˆÙŠØ© Ø§Ù„Ø¯Ù…Ø¬ â”€â”€â”€
        // 1. Ghost Ø¬Ø¯ÙŠØ¯ + Ù…ÙƒØªÙ…Ù„ Ù…ÙˆØ¬ÙˆØ¯ = ØªØ¬Ø§Ù‡Ù„ (Ø§Ù„Ù…ÙƒØªÙ…Ù„ Ø¯Ø§Ø¦Ù…Ø§Ù‹ Ø£ÙˆÙ„Ù‰)
        if newP.isGhost and not existing.isGhost
            if not isExact
                existing.confluence := existing.confluence + 1
                array.set(patterns, overlapIdx, existing)
        // 2. Ù…ÙƒØªÙ…Ù„ Ø¬Ø¯ÙŠØ¯ + ghost Ù…ÙˆØ¬ÙˆØ¯ = Ø§Ù„Ù…ÙƒØªÙ…Ù„ ÙŠØ³ØªØ¨Ø¯Ù„
        else if not newP.isGhost and existing.isGhost
            newP.confluence := existing.confluence + 1
            newP.alertedNew := false
            array.set(patterns, overlapIdx, newP)
        // 3. Ghost vs Ghost â€” exact = ØªØ¬Ø§Ù‡Ù„ | Ù…Ø®ØªÙ„Ù = Ø§Ù„Ø£ÙƒØ¨Ø± span + score ÙŠÙÙˆØ²
        else if newP.isGhost and existing.isGhost and not isExact
            int existSpan = math.abs(existing.bC - existing.bX)
            int newSpan = math.abs(newP.bC - newP.bX)
            bool newWins = newSpan > existSpan or (newSpan == existSpan and newP.score > existing.score)
            if newWins
                newP.confluence := existing.confluence + 1
                array.set(patterns, overlapIdx, newP)
            else
                existing.confluence := existing.confluence + 1
                array.set(patterns, overlapIdx, existing)
        // 4. Complete vs Complete â€” Ø§Ù„Ø£ÙƒØ¨Ø± span ÙŠÙÙˆØ²
        else
            int existSpan = math.abs(existing.bD - existing.bX)
            int newSpan = math.abs(newP.bD - newP.bX)
            bool newWins = newSpan > existSpan or (newSpan == existSpan and newP.score > existingScore)
            if newWins
                newP.confluence := existing.confluence + 1
                array.set(patterns, overlapIdx, newP)
            else
                existing.confluence := existing.confluence + 1
                array.set(patterns, overlapIdx, existing)
    else
        newP.confluence := 1
        array.unshift(patterns, newP)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘              [12] ÙƒØ´Ù Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ù…ÙƒØªÙ…Ù„Ø©                                                  â•‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
detectComplete(array<Pivot> arr, float atr, int depth) =>
    int sz = array.size(arr)
    int tMin = f_tierMin(depth)
    int MXS = 2
    if sz >= 5
        int maxD = math.min(sz - 5, SCAN_DEPTH)
        for iD = 0 to maxD
            Pivot D = array.get(arr, iD)
            int cEnd = math.min(iD + MXS + 1, sz - 4)
            for iC = iD + 1 to cEnd
                Pivot C = array.get(arr, iC)
                if C.dir != D.dir and f_legOk(arr, iD, iC, D.price, C.price)
                    int sk1 = iC - iD - 1
                    int rem1 = MXS - sk1
                    int bEnd = math.min(iC + rem1 + 1, sz - 3)
                    for iB = iC + 1 to bEnd
                        Pivot B = array.get(arr, iB)
                        if B.dir != C.dir and f_legOk(arr, iC, iB, C.price, B.price)
                            int sk2 = iB - iC - 1
                            int rem2 = rem1 - sk2
                            int aEnd = math.min(iB + rem2 + 1, sz - 2)
                            for iA = iB + 1 to aEnd
                                Pivot A = array.get(arr, iA)
                                if A.dir != B.dir and f_legOk(arr, iB, iA, B.price, A.price)
                                    int sk3 = iA - iB - 1
                                    int rem3 = rem2 - sk3
                                    int xEnd = math.min(iA + rem3 + 1, sz - 1)
                                    for iX = iA + 1 to xEnd
                                        Pivot X = array.get(arr, iX)
                                        if X.dir != A.dir and f_legOk(arr, iA, iX, A.price, X.price)
                                            int span = D.bar - X.bar
                                            if X.bar < A.bar and A.bar < B.bar and B.bar < C.bar and C.bar < D.bar and (bar_index - X.bar) < MAX_BARS and span >= tMin
                                                float XA = math.abs(A.price - X.price)
                                                float AB = math.abs(B.price - A.price)
                                                float BC = math.abs(C.price - B.price)
                                                if XA > 0.0 and AB > 0.0 and BC > 0.0
                                                    float rXAB = AB / XA
                                                    float rABC = BC / AB
                                                    bool bull = D.dir == -1
                                                    bool bValid = bull ? (B.price > X.price and B.price < A.price) : (B.price < X.price and B.price > A.price)
                                                    bool cInsideA = bull ? C.price < A.price : C.price > A.price
                                                    bool cOutsideA = not cInsideA
                                                    float rXAD = 0.0
                                                    string patName = ""
                                                    if i_Shark and cOutsideA
                                                        [bMin, bMax] = getBRange("Shark")
                                                        [cMin, cMax] = getCRange("Shark")
                                                        [dMin, dMax] = getDRange("Shark")
                                                        rXAD := math.abs(D.price - A.price) / XA
                                                        if inRange(rXAB, bMin, bMax, i_Tol) and inRange(rABC, cMin, cMax, i_Tol) and inRange(rXAD, dMin, dMax, i_Tol)
                                                            patName := "Shark"
                                                    if patName == "" and bValid and cInsideA
                                                        if i_DeepCrab
                                                            [bMin, bMax] = getBRange("Deep Crab")
                                                            [cMin, cMax] = getCRange("Deep Crab")
                                                            [dMin, dMax] = getDRange("Deep Crab")
                                                            rXAD := math.abs(D.price - A.price) / XA
                                                            if inRange(rXAB, bMin, bMax, i_Tol) and inRange(rABC, cMin, cMax, i_Tol) and inRange(rXAD, dMin, dMax, i_Tol)
                                                                patName := "Deep Crab"
                                                        if patName == "" and i_Gartley
                                                            [bMin, bMax] = getBRange("Gartley")
                                                            [cMin, cMax] = getCRange("Gartley")
                                                            [dMin, dMax] = getDRange("Gartley")
                                                            rXAD := math.abs(D.price - A.price) / XA
                                                            if inRange(rXAB, bMin, bMax, i_Tol) and inRange(rABC, cMin, cMax, i_Tol) and inRange(rXAD, dMin, dMax, i_Tol)
                                                                patName := "Gartley"
                                                        if patName == "" and i_Butterfly
                                                            [bMin, bMax] = getBRange("Butterfly")
                                                            [cMin, cMax] = getCRange("Butterfly")
                                                            [dMin, dMax] = getDRange("Butterfly")
                                                            rXAD := math.abs(D.price - A.price) / XA
                                                            if inRange(rXAB, bMin, bMax, i_Tol) and inRange(rABC, cMin, cMax, i_Tol) and inRange(rXAD, dMin, dMax, i_Tol)
                                                                patName := "Butterfly"
                                                        if patName == "" and i_Bat
                                                            [bMin, bMax] = getBRange("Bat")
                                                            [cMin, cMax] = getCRange("Bat")
                                                            [dMin, dMax] = getDRange("Bat")
                                                            rXAD := math.abs(D.price - A.price) / XA
                                                            if inRange(rXAB, bMin, bMax, i_Tol) and inRange(rABC, cMin, cMax, i_Tol) and inRange(rXAD, dMin, dMax, i_Tol)
                                                                patName := "Bat"
                                                        if patName == "" and i_AltBat
                                                            [bMin, bMax] = getBRange("Alt Bat")
                                                            [cMin, cMax] = getCRange("Alt Bat")
                                                            [dMin, dMax] = getDRange("Alt Bat")
                                                            rXAD := math.abs(D.price - A.price) / XA
                                                            if inRange(rXAB, bMin, bMax, i_Tol) and inRange(rABC, cMin, cMax, i_Tol) and inRange(rXAD, dMin, dMax, i_Tol)
                                                                patName := "Alt Bat"
                                                        if patName == "" and i_Crab
                                                            [bMin, bMax] = getBRange("Crab")
                                                            [cMin, cMax] = getCRange("Crab")
                                                            [dMin, dMax] = getDRange("Crab")
                                                            rXAD := math.abs(D.price - A.price) / XA
                                                            if inRange(rXAB, bMin, bMax, i_Tol) and inRange(rABC, cMin, cMax, i_Tol) and inRange(rXAD, dMin, dMax, i_Tol)
                                                                patName := "Crab"
                                                    if patName != ""
                                                        if f_bcEnvelope(patName, B.price, C.price, D.price, i_Tol)
                                                            float sc = calcScore(patName, rXAB, rXAD, X.bar, A.bar, B.bar, C.bar)
                                                            if sc >= 15.0
                                                                int abDuration = math.abs(B.bar - A.bar)
                                                                Pattern newP = Pattern.new(patName, bull, sc, X.price, A.price, B.price, C.price, D.price, X.bar, A.bar, B.bar, C.bar, D.bar, false, D.bar + int(abDuration * i_TimeMultiplier), 1, rXAB, rABC, rXAD)
                                                                addPattern(newP, atr, i_Sensitivity)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘              [13] ÙƒØ´Ù Ø§Ù„Ø§Ø³ØªØ¨Ø§Ù‚ÙŠ                                                         â•‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
detectEmerging(array<Pivot> arr, float atr, int depth) =>
    int sz = array.size(arr)
    int tMin = f_tierMin(depth)
    int MXS = 2
    if sz >= 4
        int maxC = math.min(sz - 4, SCAN_DEPTH)
        for iC = 0 to maxC
            Pivot C = array.get(arr, iC)
            int bEnd = math.min(iC + MXS + 1, sz - 3)
            for iB = iC + 1 to bEnd
                Pivot B = array.get(arr, iB)
                if B.dir != C.dir and f_legOk(arr, iC, iB, C.price, B.price)
                    int sk1 = iB - iC - 1
                    int rem1 = MXS - sk1
                    int aEnd = math.min(iB + rem1 + 1, sz - 2)
                    for iA = iB + 1 to aEnd
                        Pivot A = array.get(arr, iA)
                        if A.dir != B.dir and f_legOk(arr, iB, iA, B.price, A.price)
                            int sk2 = iA - iB - 1
                            int rem2 = rem1 - sk2
                            int xEnd = math.min(iA + rem2 + 1, sz - 1)
                            for iX = iA + 1 to xEnd
                                Pivot X = array.get(arr, iX)
                                if X.dir != A.dir and f_legOk(arr, iA, iX, A.price, X.price)
                                    int timeXA = math.abs(A.bar - X.bar)
                                    int span = bar_index - X.bar
                                    if X.bar < A.bar and A.bar < B.bar and B.bar < C.bar and bar_index <= (C.bar + timeXA * 3) and span >= tMin
                                        float XA = math.abs(A.price - X.price)
                                        float AB = math.abs(B.price - A.price)
                                        float BC = math.abs(C.price - B.price)
                                        if XA > 0.0 and AB > 0.0 and BC > 0.0
                                            float rXAB = AB / XA
                                            float rABC = BC / AB
                                            bool isBull = X.dir == -1
                                            bool bValid = isBull ? (B.price > X.price and B.price < A.price) : (B.price < X.price and B.price > A.price)
                                            bool cInsideA = isBull ? C.price < A.price : C.price > A.price
                                            bool cOutsideA = not cInsideA
                                            bool bBreakout = isBull ? close < B.price : close > B.price
                                            if bBreakout
                                                string gName = ""
                                                if i_Shark and cOutsideA
                                                    [bMin, bMax] = getBRange("Shark")
                                                    [cMin, cMax] = getCRange("Shark")
                                                    if inRange(rXAB, bMin, bMax, i_Tol) and inRange(rABC, cMin, cMax, i_Tol)
                                                        gName := "Shark"
                                                if gName == "" and bValid and cInsideA
                                                    if i_DeepCrab
                                                        [bMin, bMax] = getBRange("Deep Crab")
                                                        [cMin, cMax] = getCRange("Deep Crab")
                                                        if inRange(rXAB, bMin, bMax, i_Tol) and inRange(rABC, cMin, cMax, i_Tol)
                                                            gName := "Deep Crab"
                                                    if gName == "" and i_Gartley
                                                        [bMin, bMax] = getBRange("Gartley")
                                                        [cMin, cMax] = getCRange("Gartley")
                                                        if inRange(rXAB, bMin, bMax, i_Tol) and inRange(rABC, cMin, cMax, i_Tol)
                                                            gName := "Gartley"
                                                    if gName == "" and i_Butterfly
                                                        [bMin, bMax] = getBRange("Butterfly")
                                                        [cMin, cMax] = getCRange("Butterfly")
                                                        if inRange(rXAB, bMin, bMax, i_Tol) and inRange(rABC, cMin, cMax, i_Tol)
                                                            gName := "Butterfly"
                                                    if gName == "" and i_Bat
                                                        [bMin, bMax] = getBRange("Bat")
                                                        [cMin, cMax] = getCRange("Bat")
                                                        if inRange(rXAB, bMin, bMax, i_Tol) and inRange(rABC, cMin, cMax, i_Tol)
                                                            gName := "Bat"
                                                    if gName == "" and i_AltBat
                                                        [bMin, bMax] = getBRange("Alt Bat")
                                                        [cMin, cMax] = getCRange("Alt Bat")
                                                        if inRange(rXAB, bMin, bMax, i_Tol) and inRange(rABC, cMin, cMax, i_Tol)
                                                            gName := "Alt Bat"
                                                    if gName == "" and i_Crab
                                                        [bMin, bMax] = getBRange("Crab")
                                                        [cMin, cMax] = getCRange("Crab")
                                                        if inRange(rXAB, bMin, bMax, i_Tol) and inRange(rABC, cMin, cMax, i_Tol)
                                                            gName := "Crab"
                                                if gName != ""
                                                    [xaTarget, xaRatio] = calc_XA_Anchor(gName, X.price, A.price, isBull)
                                                    float targetD = na(xaTarget) ? close : xaTarget
                                                    int projBar = C.bar + timeXA
                                                    if projBar <= bar_index
                                                        projBar := bar_index + 5
                                                    [dMin, dMax] = getDRange(gName)
                                                    float idealD = (dMin + dMax) / 2.0
                                                    float sc = calcScore(gName, rXAB, idealD, X.bar, A.bar, B.bar, C.bar)
                                                    if sc >= 15.0
                                                        int abDuration = math.abs(B.bar - A.bar)
                                                        Pattern ghost = Pattern.new(gName, isBull, sc, X.price, A.price, B.price, C.price, targetD, X.bar, A.bar, B.bar, C.bar, projBar, true, projBar + int(abDuration * i_TimeMultiplier), 1, rXAB, rABC, idealD)
                                                        addPattern(ghost, atr, i_Sensitivity)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘                              [14-15] Ghost Helpers                                      â•‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
getTop2PowerGhosts(float atr) =>
    array<Pattern> gl = array.new<Pattern>()
    array<float> pl = array.new_float()
    int sz = array.size(patterns)
    if sz > 0
        for i = 0 to sz - 1
            Pattern p = array.get(patterns, i)
            if p.isGhost
                float xa = math.abs(p.pA - p.pX)
                float safeAtr = atr > 0 ? atr : 1.0
                float confBonus = p.confluence > 1 ? 1.0 + (p.confluence - 1) * 0.25 : 1.0
                array.push(gl, p)
                array.push(pl, p.score * (xa / safeAtr) * confBonus)
    Pattern top1 = na, Pattern top2 = na
    float m1 = 0.0, float m2 = 0.0
    int idx1 = -1
    int gsz = array.size(gl)
    if gsz > 0
        for i = 0 to gsz - 1
            float pw = array.get(pl, i)
            if pw > m1
                m1 := pw
                top1 := array.get(gl, i)
                idx1 := i
        for i = 0 to gsz - 1
            if i != idx1
                float pw = array.get(pl, i)
                if pw > m2
                    m2 := pw
                    top2 := array.get(gl, i)
    [top1, top2]

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘              [15] ØªØ±Ù‚ÙŠØ© Ø§Ù„Ø£Ø´Ø¨Ø§Ø­ â€” Ghost â†’ Complete                                        â•‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
promoteGhosts(float atr) =>
    int sz = array.size(patterns)
    if sz > 0
        for i = 0 to sz - 1
            if i < array.size(patterns)
                Pattern p = array.get(patterns, i)
                if p.isGhost
                    // Bull: Ø§Ù„Ø³Ø¹Ø± Ù†Ø²Ù„ Ù„Ù…Ù†Ø·Ù‚Ø© D | Bear: Ø§Ù„Ø³Ø¹Ø± ØµØ¹Ø¯ Ù„Ù…Ù†Ø·Ù‚Ø© D
                    float tolerance = atr * 0.5
                    bool reached = p.isBull ? (low <= p.pD + tolerance) : (high >= p.pD - tolerance)
                    if reached
                        p.isGhost := false
                        p.bD := bar_index
                        p.pD := p.isBull ? low : high
                        array.set(patterns, i, p)

removeGhosts() =>
    int sz = array.size(patterns)
    if sz > 0
        for i = sz - 1 to 0
            if i < array.size(patterns)
                Pattern p = array.get(patterns, i)
                if p.isGhost and bar_index > p.timeLimit
                    array.remove(patterns, i)

// â”€â”€â”€ ØªÙ†Ø¸ÙŠÙ Ø°Ø§ØªÙŠ: Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ù…Ù†ØªÙ‡ÙŠØ© â”€â”€â”€
cleanStale() =>
    int sz = array.size(patterns)
    if sz > 0
        for i = sz - 1 to 0
            if i < array.size(patterns)
                Pattern p = array.get(patterns, i)
                bool remove = false
                // 1. Ù†Ù…Ø· Ø£Ù‚Ø¯Ù… Ù…Ù† MAX_BARS Ø´Ù…Ø¹Ø© â€” Ù…Ù†ØªÙ‡ÙŠ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ©
                if (bar_index - p.bX) >= MAX_BARS
                    remove := true
                // 2. Ù†Ù…Ø· Ù…ÙƒØªÙ…Ù„: TP2 + SL ÙƒÙ„Ø§Ù‡Ù…Ø§ ØªØ­Ù‚Ù‚ = Ø§ÙƒØªÙ…Ù„ Ø¯ÙˆØ±Ù‡ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„
                if not p.isGhost and p.alertedTP2 and p.alertedSL
                    remove := true
                if remove
                    array.remove(patterns, i)

purgeGhostDupes(float atr) =>
    bool changed = true
    while changed
        changed := false
        int sz = array.size(patterns)
        if sz > 1
            for i = sz - 1 to 1
                if not changed and i < array.size(patterns)
                    Pattern a = array.get(patterns, i)
                    if a.isGhost
                        for j = i - 1 to 0
                            if not changed and j < array.size(patterns)
                                Pattern b = array.get(patterns, j)
                                if b.isGhost and a.isBull == b.isBull and a.name == b.name
                                    bool dClose = atr > 0 ? math.abs(a.pD - b.pD) <= atr : false
                                    if dClose
                                        if a.score >= b.score
                                            a.confluence := a.confluence + b.confluence
                                            array.set(patterns, i, a)
                                            array.remove(patterns, j)
                                        else
                                            b.confluence := b.confluence + a.confluence
                                            array.set(patterns, j, b)
                                            array.remove(patterns, i)
                                        changed := true

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘              [16] Ø§Ù„ØªÙ†ÙÙŠØ° Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ                                                       â•‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if barstate.isconfirmed
    updatePivots(pv1, ph1, pl1, d1)
    updatePivots(pv2, ph2, pl2, d2)
    updatePivots(pv2b, ph2b, pl2b, d2b)
    updatePivots(pv3, ph3, pl3, d3)
    updatePivots(pv4, ph4, pl4, d4)
    updatePivots(pv5b, ph5b, pl5b, d5b)
    updatePivots(pv5, ph5, pl5, d5)
    updatePivots(pv6, ph6, pl6, d6)
    updatePivots(pv7, ph7, pl7, d7)
    updatePivots(pv8, ph8, pl8, d8)
    
    if not na(ph1) or not na(pl1)
        dirty1 := true
    if not na(ph2) or not na(pl2)
        dirty2 := true
    if not na(ph2b) or not na(pl2b)
        dirty2b := true
    if not na(ph3) or not na(pl3)
        dirty3 := true
    if not na(ph4) or not na(pl4)
        dirty4 := true
    if not na(ph5b) or not na(pl5b)
        dirty5b := true
    if not na(ph5) or not na(pl5)
        dirty5 := true
    if not na(ph6) or not na(pl6)
        dirty6 := true
    if not na(ph7) or not na(pl7)
        dirty7 := true
    if not na(ph8) or not na(pl8)
        dirty8 := true
    
    if dirty8
        detectComplete(pv8, atrVal, d8)
        dirty8 := false
    if dirty7
        detectComplete(pv7, atrVal, d7)
        dirty7 := false
    if dirty6
        detectComplete(pv6, atrVal, d6)
        dirty6 := false
    if dirty5
        detectComplete(pv5, atrVal, d5)
        dirty5 := false
    if dirty5b
        detectComplete(pv5b, atrVal, d5b)
        dirty5b := false
    if dirty4
        detectComplete(pv4, atrVal, d4)
        dirty4 := false
    if dirty3
        detectComplete(pv3, atrVal, d3)
        dirty3 := false
    if dirty2b
        detectComplete(pv2b, atrVal, d2b)
        dirty2b := false
    if dirty2
        detectComplete(pv2, atrVal, d2)
        dirty2 := false
    if dirty1
        detectComplete(pv1, atrVal, d1)
        dirty1 := false
    
    promoteGhosts(atrVal)

if barstate.islast
    removeGhosts()
    detectEmerging(pv8, atrVal, d8)
    detectEmerging(pv7, atrVal, d7)
    detectEmerging(pv6, atrVal, d6)
    detectEmerging(pv5, atrVal, d5)
    detectEmerging(pv5b, atrVal, d5b)
    detectEmerging(pv4, atrVal, d4)
    detectEmerging(pv3, atrVal, d3)
    detectEmerging(pv2b, atrVal, d2b)
    detectEmerging(pv2, atrVal, d2)
    detectEmerging(pv1, atrVal, d1)
    purgeGhostDupes(atrVal)
    while array.size(patterns) > MAX_PAT
        array.pop(patterns)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘              [17] Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ â€” THEMED                                                â•‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if barstate.islast
    for ln in gLines
        line.delete(ln)
    array.clear(gLines)
    for lb in gLabels
        label.delete(lb)
    array.clear(gLabels)
    array.clear(drawnLvls)
    [topGhost1, topGhost2] = getTop2PowerGhosts(atrVal)
    int cnt = math.min(array.size(patterns), i_MaxPat)
    if cnt > 0
        for i = 0 to cnt - 1
            Pattern p = array.get(patterns, i)
            if p.isGhost
                bool isTop1 = not na(topGhost1) ? (p.bX == topGhost1.bX and p.bA == topGhost1.bA and p.name == topGhost1.name) : false
                bool isTop2 = not na(topGhost2) ? (p.bX == topGhost2.bX and p.bA == topGhost2.bA and p.name == topGhost2.name) : false
                if not isTop1 and not isTop2
                    continue
            if (bar_index - p.bX) < MAX_BARS
                color mainCol = p.isGhost ? T_GHOST : (p.isBull ? T_BULL : T_BEAR)
                color lineCol = color.new(T_LSR, 20)
                color fadeCol = color.new(T_LSR, 70)
                int patSpan = math.abs(p.bC - p.bX)
                int cdLen = p.isGhost ? math.max(5, int(patSpan * 0.15)) : 0
                int dBar = p.isGhost ? (p.bC + cdLen) : p.bD
                float dPrice = p.pD
                // Ø£Ø¶Ù„Ø§Ø¹ Ø§Ù„Ù†Ù…Ø·
                array.push(gLines, line.new(p.bX, p.pX, p.bA, p.pA, color=lineCol, style=line.style_dotted, width=1))
                array.push(gLines, line.new(p.bA, p.pA, p.bB, p.pB, color=lineCol, style=line.style_dotted, width=1))
                array.push(gLines, line.new(p.bB, p.pB, p.bC, p.pC, color=lineCol, style=line.style_dotted, width=1))
                array.push(gLines, line.new(p.bC, p.pC, dBar, dPrice, color=lineCol, style=line.style_dotted, width=1))
                // Ø¸Ù„ Ù‡Ù†Ø¯Ø³ÙŠ
                array.push(gLines, line.new(p.bX, p.pX, p.bB, p.pB, color=fadeCol, style=line.style_dotted, width=1))
                array.push(gLines, line.new(p.bA, p.pA, p.bC, p.pC, color=fadeCol, style=line.style_dotted, width=1))
                array.push(gLines, line.new(p.bB, p.pB, dBar, dPrice, color=fadeCol, style=line.style_dotted, width=1))
                if i_ShowLabels
                    array.push(gLabels, label.new(p.bX, p.pX, "X", color=color.new(color.white, 100), textcolor=T_LABELS, style=label.style_none, size=size.tiny))
                    array.push(gLabels, label.new(p.bA, p.pA, "A", color=color.new(color.white, 100), textcolor=T_LABELS, style=label.style_none, size=size.tiny))
                    array.push(gLabels, label.new(p.bB, p.pB, "B", color=color.new(color.white, 100), textcolor=T_LABELS, style=label.style_none, size=size.tiny))
                    array.push(gLabels, label.new(p.bC, p.pC, "C", color=color.new(color.white, 100), textcolor=T_LABELS, style=label.style_none, size=size.tiny))
                    if not p.isGhost
                        array.push(gLabels, label.new(p.bD, p.pD, "D", color=color.new(color.white, 100), textcolor=T_LABELS, style=label.style_none, size=size.tiny))
                // â”€â”€ Ø§Ø³Ù… Ø§Ù„Ù†Ù…Ø· ÙÙ‚Ø· Ø¹Ù†Ø¯ D â”€â”€
                // Ghost Quality â€” inline (Ø¨Ø¯ÙˆÙ† function Ù„ØªÙØ§Ø¯ÙŠ Pine warning)
                int ghostQuality = 0
                if _gq_volOk
                    ghostQuality += 1
                if (p.isBull and _gq_zScore <= -i_ZScoreMin) or (not p.isBull and _gq_zScore >= i_ZScoreMin)
                    ghostQuality += 1
                if p.bX > 0 and p.bX < bar_index
                    int _gq_lb = bar_index - p.bX
                    if _gq_lb < math.min(500, bar_index)
                        if p.isBull
                            if close < p.pX and rsiVal > rsiVal[_gq_lb]
                                ghostQuality += 1
                        else
                            if close > p.pX and rsiVal < rsiVal[_gq_lb]
                                ghostQuality += 1
                string sensorTxt = ""
                if p.isGhost and i_EnableSensors
                    sensorTxt := ghostQuality == 3 ? " â˜…â˜…â˜…" : ghostQuality == 2 ? " â˜…â˜…" : ghostQuality == 1 ? " â˜…" : ""
                string confTxt = p.confluence > 1 ? " Ã—" + str.tostring(p.confluence) : ""
                // ğŸ§  Quality Score â€” Ø¹Ø±Ø¶ Ø§Ù„Ù†Ø³Ø¨Ø© Ø¨Ø¬Ø§Ù†Ø¨ Ø§Ø³Ù… Ø§Ù„Ù…ÙƒØªÙ…Ù„
                string qTxt = ""
                if not p.isGhost
                    [qs, qd, qv, qt] = f_qualityScore(p.name, p.isBull, p.rXAB, p.rABC, p.rXAD, p.bX, p.bA, p.bB, p.bC, p.bD, p.pX, p.pD)
                    qTxt := " " + str.tostring(qs) + "%"
                string nameTxt = f_patName(p.name) + (p.isGhost ? " â—" : "") + qTxt + confTxt + sensorTxt
                // Ø§Ø³Ù… Ø§Ù„Ù†Ù…Ø· Ø¹Ù†Ø¯ D Ø¨Ù…Ø³Ø§ÙØ© 0.3%
                float nameOffset = dPrice * 0.003
                if p.isBull
                    array.push(gLabels, label.new(dBar, dPrice - nameOffset, nameTxt, color=color.new(mainCol, 88), textcolor=mainCol, style=label.style_label_up, size=size.tiny))
                else
                    array.push(gLabels, label.new(dBar, dPrice + nameOffset, nameTxt, color=color.new(mainCol, 88), textcolor=mainCol, style=label.style_label_down, size=size.tiny))
                // Ø§Ù„Ù†Ø³Ø¨ ØªØ¨Ø¯Ø£ Ù…Ù† Ø§Ù„Ø´Ù…Ø¹Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ù„Ù„Ø§Ø³ØªØ¨Ø§Ù‚ÙŠØŒ Ù…Ù† D Ù„Ù„Ù…ÙƒØªÙ…Ù„
                int lvlStart = p.isGhost ? (bar_index - 3) : dBar
                int lvlEnd = p.isGhost ? (bar_index + 5) : (dBar + 15)
                int lblOffset = lvlEnd
                float closestBC = na
                // â•â•â• ğŸŸ¡ ENGINE 1: BC RADAR (v60 Logic) â•â•â•
                if i_ShowPRZ
                    [bcLevels, bcRatios] = calc_BC_Levels(p.name, p.pB, p.pC)
                    float refPrice = p.isGhost ? close : p.pD
                    [upperLvl, upperRat, lowerLvl, lowerRat, closestLvl, closestRat] = find_Bracket_Levels(bcLevels, bcRatios, refPrice, p.isBull)
                    closestBC := closestLvl
                    if not na(upperLvl) and f_lvlNew(upperLvl)
                        array.push(drawnLvls, upperLvl)
                        array.push(gLines, line.new(lvlStart, upperLvl, lvlEnd, upperLvl, color=color.new(T_PRZ, 30), style=line.style_dotted, width=1))
                        array.push(gLabels, label.new(lblOffset, upperLvl, str.tostring(upperRat, "#.###") + " BC", color=color.new(color.white, 100), textcolor=T_PRZ, style=label.style_label_left, size=size.tiny))
                    if not na(lowerLvl) and f_lvlNew(lowerLvl)
                        array.push(drawnLvls, lowerLvl)
                        array.push(gLines, line.new(lvlStart, lowerLvl, lvlEnd, lowerLvl, color=color.new(T_PRZ, 30), style=line.style_dotted, width=1))
                        array.push(gLabels, label.new(lblOffset, lowerLvl, str.tostring(lowerRat, "#.###") + " BC", color=color.new(color.white, 100), textcolor=T_PRZ, style=label.style_label_left, size=size.tiny))
                // â•â•â• â­ ENGINE 2: XA ANCHOR â€” Smart Bracket (ÙƒÙ„ Ø§Ù„Ø£Ù†Ù…Ø§Ø·) â•â•â•
                if i_ShowXA
                    [xaLevels, xaRatios] = calc_XA_Levels(p.name, p.pX, p.pA, p.isBull)
                    float xaRef = p.isGhost ? close : p.pD
                    [xaUp, xaUpR, xaLo, xaLoR, xaClosest, xaClosestR] = find_Bracket_Levels(xaLevels, xaRatios, xaRef, p.isBull)
                    if not na(xaUp) and f_lvlNew(xaUp)
                        array.push(drawnLvls, xaUp)
                        array.push(gLines, line.new(lvlStart, xaUp, lvlEnd, xaUp, color=color.new(T_XA, 30), style=line.style_dotted, width=1))
                        array.push(gLabels, label.new(lblOffset, xaUp, str.tostring(xaUpR, "#.###") + " XA", color=color.new(color.white, 100), textcolor=T_XA, style=label.style_label_left, size=size.tiny))
                    if not na(xaLo) and xaLo != xaUp and f_lvlNew(xaLo)
                        array.push(drawnLvls, xaLo)
                        array.push(gLines, line.new(lvlStart, xaLo, lvlEnd, xaLo, color=color.new(T_XA, 30), style=line.style_dotted, width=1))
                        array.push(gLabels, label.new(lblOffset, xaLo, str.tostring(xaLoR, "#.###") + " XA", color=color.new(color.white, 100), textcolor=T_XA, style=label.style_label_left, size=size.tiny))
                if i_ShowTP
                    float calcD = p.isGhost ? (na(closestBC) ? p.pD : closestBC) : p.pD
                    [tp1, tp2] = calc_TP_Levels(p.pC, calcD, i_TP1_R, i_TP2_R)
                    bool tp1Hit = not na(tp1) and (p.isBull ? close > tp1 : close < tp1)
                    bool tp2Hit = not na(tp2) and (p.isBull ? close > tp2 : close < tp2)
                    if not tp1Hit and not na(tp1) and f_lvlNew(tp1)
                        array.push(drawnLvls, tp1)
                        array.push(gLines, line.new(lvlStart, tp1, lvlEnd, tp1, color=color.new(T_TP, 30), style=line.style_dotted, width=1))
                        array.push(gLabels, label.new(lblOffset, tp1, str.tostring(i_TP1_R, "#.##") + " CD", color=color.new(color.white, 100), textcolor=T_TP, style=label.style_label_left, size=size.tiny))
                    if not tp2Hit and not na(tp2) and f_lvlNew(tp2)
                        array.push(drawnLvls, tp2)
                        array.push(gLines, line.new(lvlStart, tp2, lvlEnd, tp2, color=color.new(T_TP, 50), style=line.style_dotted, width=1))
                        array.push(gLabels, label.new(lblOffset, tp2, str.tostring(i_TP2_R, "#.##") + " CD", color=color.new(color.white, 100), textcolor=color.new(T_TP, 30), style=label.style_label_left, size=size.tiny))

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘              [17] Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø³ÙˆÙ‚ â€” Data Feeds (25 of 40)                                    â•‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
[_btcP, _btcC]   = request.security("BINANCE:BTCUSDT", "D", [close, (close - close[1]) / close[1] * 100], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
[_ethP, _ethC]   = request.security("BINANCE:ETHUSDT", "D", [close, (close - close[1]) / close[1] * 100], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
[_btcD, _btcDC]  = request.security("CRYPTOCAP:BTC.D", "D", [close, ta.change(close)], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
[_usdtD, _usdtDC]= request.security("CRYPTOCAP:USDT.D", "D", [close, ta.change(close)], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
[_total, _totC]  = request.security("CRYPTOCAP:TOTAL", "D", [close, (close - close[1]) / close[1] * 100], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
[_tot3, _tot3C]  = request.security("CRYPTOCAP:TOTAL3", "D", [close, (close - close[1]) / close[1] * 100], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
[_ethD, _ethDC]  = request.security("CRYPTOCAP:ETH.D", "D", [close, ta.change(close)], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
[_othD, _othDC]  = request.security("CRYPTOCAP:OTHERS.D", "D", [close, ta.change(close)], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
[_tot2, _tot2C]  = request.security("CRYPTOCAP:TOTAL2", "D", [close, (close - close[1]) / close[1] * 100], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
float _vix       = request.security("CBOE:VIX", "D", close, ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
[_dxy, _dxyC]    = request.security("TVC:DXY", "D", [close, (close - close[1]) / close[1] * 100], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
[_gold, _goldC]  = request.security("OANDA:XAUUSD", "D", [close, (close - close[1]) / close[1] * 100], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
// --- Oil: NYMEX futures primary, TVC fallback ---
[_wtiRaw, _wtiCRaw]     = request.security("NYMEX:CL1!", "D", [close, (close - close[1]) / close[1] * 100], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
[_wtiFB, _wtiCFB]       = request.security("TVC:USOIL", "D", [close, (close - close[1]) / close[1] * 100], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
float _wti  = na(_wtiRaw) ? _wtiFB : _wtiRaw
float _wtiC = na(_wtiCRaw) ? _wtiCFB : _wtiCRaw
[_brentRaw, _brentCRaw] = request.security("NYMEX:BZ1!", "D", [close, (close - close[1]) / close[1] * 100], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
[_brentFB, _brentCFB]   = request.security("TVC:UKOIL", "D", [close, (close - close[1]) / close[1] * 100], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
float _brent  = na(_brentRaw) ? _brentFB : _brentRaw
float _brentC = na(_brentCRaw) ? _brentCFB : _brentCRaw
// --- Indices: Dow Jones + TASI ---
[_dji, _djiC]    = request.security("DJ:DJI", "D", [close, (close - close[1]) / close[1] * 100], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
[_tasi, _tasiC]  = request.security("TADAWUL:TASI", "D", [close, (close - close[1]) / close[1] * 100], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
[_walcl, _walclC]= request.security("FRED:WALCL", "W", [close, (close - close[1]) / close[1] * 100], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
[_usir, _usirC]  = request.security("FRED:FEDFUNDS", "M", [close, ta.change(close)], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
// --- Titans: gaps_off + lookahead_on = Ø¢Ø®Ø± Ù‚ÙŠÙ…Ø© Ø¯Ø§Ø¦Ù…Ø§Ù‹ Ø­ØªÙ‰ Ù„Ùˆ Ø§Ù„Ø³ÙˆÙ‚ Ù…ØºÙ„Ù‚ ---
[_tsla, _tslaC]  = request.security("NASDAQ:TSLA", "D", [close, (close - close[1]) / close[1] * 100], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
[_mstr, _mstrC]  = request.security("NASDAQ:MSTR", "D", [close, (close - close[1]) / close[1] * 100], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
[_ibitRaw, _ibitCRaw] = request.security("NASDAQ:IBIT", "D", [close, (close - close[1]) / close[1] * 100], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
[_coin, _coinC]  = request.security("NASDAQ:COIN", "D", [close, (close - close[1]) / close[1] * 100], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
// Fallback: BITO as backup for IBIT/FBTC
[_bitoP, _bitoC] = request.security("AMEX:BITO", "D", [close, (close - close[1]) / close[1] * 100], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
float _ibit  = na(_ibitRaw) ? _bitoP : _ibitRaw
float _ibitC = na(_ibitCRaw) ? _bitoC : _ibitCRaw
[_fet, _fetC]    = request.security("BINANCE:FETUSDT", "D", [close, (close - close[1]) / close[1] * 100], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
[_doge, _dogeC]  = request.security("BINANCE:DOGEUSDT", "D", [close, (close - close[1]) / close[1] * 100], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
[_ondo, _ondoC]  = request.security("BINANCE:ONDOUSDT", "D", [close, (close - close[1]) / close[1] * 100], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
[_sol, _solC]    = request.security("BINANCE:SOLUSDT", "D", [close, (close - close[1]) / close[1] * 100], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
[_imx, _imxC]    = request.security("BINANCE:IMXUSDT", "D", [close, (close - close[1]) / close[1] * 100], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
[_aave, _aaveC]  = request.security("BINANCE:AAVEUSDT", "D", [close, (close - close[1]) / close[1] * 100], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
// --- New Sectors: Oracles, L2, DeFi-2, Meme-2, AI-2 ---
[_rndr, _rndrC]  = request.security("BINANCE:RENDERUSDT", "D", [close, (close - close[1]) / close[1] * 100], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
[_pepe, _pepeC]  = request.security("BINANCE:PEPEUSDT", "D", [close, (close - close[1]) / close[1] * 100], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
[_link, _linkC]  = request.security("BINANCE:LINKUSDT", "D", [close, (close - close[1]) / close[1] * 100], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
[_arb, _arbC]    = request.security("BINANCE:ARBUSDT", "D", [close, (close - close[1]) / close[1] * 100], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
[_uni, _uniC]    = request.security("BINANCE:UNIUSDT", "D", [close, (close - close[1]) / close[1] * 100], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
// --- Titans expansion: Saylor basket + BlackRock parent ---
[_mara, _maraC]  = request.security("NASDAQ:MARA", "D", [close, (close - close[1]) / close[1] * 100], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
[_blk, _blkC]    = request.security("NYSE:BLK", "D", [close, (close - close[1]) / close[1] * 100], ignore_invalid_symbol=true, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)

// Pre-compute FED in trillions
// FED: FRED:WALCL is in millions, divide by 1,000,000 to get trillions
// FED: display computed inline to avoid variable ordering issues
// SSR: Stablecoin Supply Ratio (buying power proxy) = 100 / USDT.D
float _ssr = na(_usdtD) or _usdtD <= 0 ? na : 100.0 / _usdtD
float _ssrPrev = na(_usdtD) or na(_usdtDC) ? na : 100.0 / (_usdtD - _usdtDC)
float _ssrC = na(_ssr) or na(_ssrPrev) ? na : _ssr - _ssrPrev
// BTC/OTHERS ratio
float _btcOth = (na(_btcD) or na(_othD) or _othD <= 0) ? na : _btcD / _othD
float _btcOthC = na(_btcDC) or na(_othDC) ? na : _btcDC - _othDC

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘              [18] Ù…Ù†Ø¸ÙˆÙ…Ø© Ø§Ù„Ø±ØµØ¯ ÙˆØ§Ù„ØªØ­ØµÙŠÙ† â€” Multi-Lang 6 Gates                              â•‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘              [18] ğŸŒ LANGUAGE ENGINE â€” Ù…Ø­Ø±Ùƒ Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø´Ø§Ù…Ù„                                â•‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€ Ù…ØµÙÙˆÙØ© Ø§Ù„ØªØ±Ø¬Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© (UI Matrix) â”€â”€â”€
// Alert body texts â€” ØªØªØ¨Ø¹ i_Lang
string _L_COMPLETE  = i_Lang == "Arabic" ? "Ø¨Ù†ÙŠØ© Ù…ÙƒØªÙ…Ù„Ø©" : i_Lang == "Chinese" ? "æ¨¡å¼å®Œæˆ" : i_Lang == "Turkish" ? "YapÄ± Tamam" : i_Lang == "Russian" ? "Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ°" : "Structure Formed"
string _L_SECTOR    = i_Lang == "Arabic" ? "ØªØ²Ø§Ù…Ù† Ù‚Ø·Ø§Ø¹ÙŠ" : i_Lang == "Chinese" ? "æ¿å—åŒæ­¥" : i_Lang == "Turkish" ? "SektÃ¶r Senkron" : i_Lang == "Russian" ? "Ğ¡ĞµĞºÑ‚Ğ¾Ñ€ Ğ¡Ğ¸Ğ½Ñ…Ñ€Ğ¾Ğ½" : "Sector Sync"
string _L_VOLUME    = i_Lang == "Arabic" ? "ØªØ£ÙƒÙŠØ¯ Ø³ÙŠÙˆÙ„Ø©" : i_Lang == "Chinese" ? "æµåŠ¨æ€§ç¡®è®¤" : i_Lang == "Turkish" ? "Likidite OnayÄ±" : i_Lang == "Russian" ? "Ğ›Ğ¸ĞºĞ²Ğ¸Ğ´Ğ½Ğ¾ÑÑ‚ÑŒ" : "Liquidity Confirm"
string _L_GHOST     = i_Lang == "Arabic" ? "Ø¥Ø´Ø§Ø±Ø© Ø§Ø³ØªØ¨Ø§Ù‚ÙŠØ©" : i_Lang == "Chinese" ? "å¹½çµä¿¡å·" : i_Lang == "Turkish" ? "Hayalet Sinyal" : i_Lang == "Russian" ? "ĞŸÑ€Ğ¸Ğ·Ñ€Ğ°Ñ‡Ğ½Ñ‹Ğ¹ Ğ¡Ğ¸Ğ³Ğ½Ğ°Ğ»" : "Ghost Signal"
string _L_TARGET    = i_Lang == "Arabic" ? "Ø§Ù„Ù‡Ø¯Ù" : i_Lang == "Chinese" ? "ç›®æ ‡" : i_Lang == "Turkish" ? "Hedef" : i_Lang == "Russian" ? "Ğ¦ĞµĞ»ÑŒ" : "Target Hit"
string _L_INVALID   = i_Lang == "Arabic" ? "Ø¥Ø¨Ø·Ø§Ù„" : i_Lang == "Chinese" ? "å¤±æ•ˆ" : i_Lang == "Turkish" ? "GeÃ§ersiz" : i_Lang == "Russian" ? "ĞĞµĞ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ‚ĞµĞ»ĞµĞ½" : "Invalidated"

// â”€â”€â”€ ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø´Ø§Ø±Øª ÙˆØ§Ù„Ø¬Ø¯Ø§ÙˆÙ„ (Chart UI) â”€â”€â”€
string _L_ENTRY     = i_Lang == "Arabic" ? "Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø¯Ø®ÙˆÙ„" : i_Lang == "Chinese" ? "å…¥åœºåŒºåŸŸ" : i_Lang == "Turkish" ? "GiriÅŸ BÃ¶lgesi" : i_Lang == "Russian" ? "Ğ—Ğ¾Ğ½Ğ° Ğ²Ñ…Ğ¾Ğ´Ğ°" : "Entry Zone"
string _L_STOPLOSS  = i_Lang == "Arabic" ? "ÙˆÙ‚Ù Ø§Ù„Ø®Ø³Ø§Ø±Ø©" : i_Lang == "Chinese" ? "æ­¢æŸ" : i_Lang == "Turkish" ? "Zarar Durdur" : i_Lang == "Russian" ? "Ğ¡Ñ‚Ğ¾Ğ¿-Ğ»Ğ¾ÑÑ" : "Stop Loss"
string _L_DASHBOARD = i_Lang == "Arabic" ? "Ù„ÙˆØ­Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª" : i_Lang == "Chinese" ? "ä»ªè¡¨æ¿" : i_Lang == "Turkish" ? "Panel" : i_Lang == "Russian" ? "ĞŸĞ°Ğ½ĞµĞ»ÑŒ" : "Dashboard"

// â”€â”€â”€ Ø§Ù„Ø¯Ø±Ø¹ Ø§Ù„Ù‚Ø§Ù†ÙˆÙ†ÙŠ ÙˆØ§Ù„Ø³ÙŠØ§Ø¯ÙŠ (Legal Seal) â”€â”€â”€
string _L_SEAL = i_Lang == "Arabic" ? "Ø§Ø¯Ø§Ø© Ù…Ø­Ø§ÙƒØ§Ø© Ù…Ø³Ø§Ø¹Ø¯Ù‡" : i_Lang == "Chinese" ? "è¾…åŠ©æ¨¡æ‹Ÿå·¥å…·" : i_Lang == "Turkish" ? "YardÄ±mcÄ± SimÃ¼lasyon" : i_Lang == "Russian" ? "Ğ’ÑĞ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ°Ñ ÑĞ¸Ğ¼ÑƒĞ»ÑÑ†Ğ¸Ñ" : "Assisting Simulation"
string _L_RESP = "ğ• Rzin_Bitcoin"
string _L_DISC = _L_SEAL + " | " + _L_RESP
string _LEGAL = "\nâ¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯\n" + _L_DISC + "\nSAUDI ARABIA"

// â”€â”€â”€ Dashboard Labels â€” ØªØ³Ù…ÙŠØ§Øª Ø§Ù„Ø¯Ø§Ø´Ø¨ÙˆØ±Ø¯ â”€â”€â”€
string _D_BTCD   = i_Lang == "Arabic" ? "Ù‡ÙŠÙ…Ù†Ø© B" : i_Lang == "Chinese" ? "BTCä¸»å¯¼" : i_Lang == "Turkish" ? "BTC Hak." : i_Lang == "Russian" ? "BTC Ğ”Ğ¾Ğ¼." : "BTC.D"
string _D_ETHD   = i_Lang == "Arabic" ? "Ù‡ÙŠÙ…Ù†Ø© E" : i_Lang == "Chinese" ? "ETHä¸»å¯¼" : i_Lang == "Turkish" ? "ETH Hak." : i_Lang == "Russian" ? "ETH Ğ”Ğ¾Ğ¼." : "ETH.D"
string _D_OTHD   = i_Lang == "Arabic" ? "Ù‡ÙŠÙ…Ù†Ø© A" : i_Lang == "Chinese" ? "ALTä¸»å¯¼" : i_Lang == "Turkish" ? "ALT Hak." : i_Lang == "Russian" ? "ALT Ğ”Ğ¾Ğ¼." : "OTH.D"
string _D_USDTD  = i_Lang == "Arabic" ? "Ù‡ÙŠÙ…Ù†Ø© U" : i_Lang == "Chinese" ? "USDTä¸»å¯¼" : i_Lang == "Turkish" ? "USDT Hak." : i_Lang == "Russian" ? "USDT Ğ”Ğ¾Ğ¼." : "USDT.D"
string _D_TOTAL  = i_Lang == "Arabic" ? "Ø§Ù„Ø³ÙŠÙˆÙ„Ø©" : i_Lang == "Chinese" ? "æ€»å¸‚å€¼" : i_Lang == "Turkish" ? "Toplam" : i_Lang == "Russian" ? "ĞĞ±Ñ‰Ğ¸Ğ¹" : "TOTAL"
string _D_TOT2   = i_Lang == "Arabic" ? "Ø¨Ù„Ø§BTC" : i_Lang == "Chinese" ? "æ— BTC" : i_Lang == "Turkish" ? "BTC'siz" : i_Lang == "Russian" ? "Ğ‘ĞµĞ· BTC" : "TOT2"
string _D_TOT3   = i_Lang == "Arabic" ? "Ø¨Ù„Ø§ETH" : i_Lang == "Chinese" ? "æ— ETH" : i_Lang == "Turkish" ? "ETH'siz" : i_Lang == "Russian" ? "Ğ‘ĞµĞ· ETH" : "TOT3"
string _D_BO     = i_Lang == "Arabic" ? "B/O" : i_Lang == "Chinese" ? "B/Oæ¯”" : i_Lang == "Turkish" ? "B/O Oran" : i_Lang == "Russian" ? "B/O Ğ Ğ°Ñ‚." : "B/O"
string _D_SSR    = i_Lang == "Arabic" ? "Ø´Ø±Ø§Ø¦ÙŠØ©" : i_Lang == "Chinese" ? "è´­ä¹°åŠ›" : i_Lang == "Turkish" ? "AlÄ±m GÃ¼cÃ¼" : i_Lang == "Russian" ? "ĞŸĞ¾ĞºÑƒĞ¿ĞºĞ°" : "SSR"
string _D_DXY    = i_Lang == "Arabic" ? "Ø§Ù„Ø¯ÙˆÙ„Ø§Ø±" : i_Lang == "Chinese" ? "ç¾å…ƒ" : i_Lang == "Turkish" ? "Dolar" : i_Lang == "Russian" ? "Ğ”Ğ¾Ğ»Ğ»Ğ°Ñ€" : "DXY"
string _D_GOLD   = i_Lang == "Arabic" ? "Ø§Ù„Ø°Ù‡Ø¨" : i_Lang == "Chinese" ? "é»„é‡‘" : i_Lang == "Turkish" ? "AltÄ±n" : i_Lang == "Russian" ? "Ğ—Ğ¾Ğ»Ğ¾Ñ‚Ğ¾" : "GOLD"
string _D_OIL_W  = i_Lang == "Arabic" ? "Ù†ÙØ· US" : i_Lang == "Chinese" ? "ç¾æ²¹" : i_Lang == "Turkish" ? "ABD Petrol" : i_Lang == "Russian" ? "ĞĞµÑ„Ñ‚ÑŒ US" : "WTI"
string _D_OIL_B  = i_Lang == "Arabic" ? "Ø¨Ø±Ù†Øª" : i_Lang == "Chinese" ? "å¸ƒæ²¹" : i_Lang == "Turkish" ? "Brent" : i_Lang == "Russian" ? "Ğ‘Ñ€ĞµĞ½Ñ‚" : "BRENT"
string _D_FED    = i_Lang == "Arabic" ? "ÙØ¯Ø±Ø§Ù„ÙŠ" : i_Lang == "Chinese" ? "è”å‚¨" : i_Lang == "Turkish" ? "FED" : i_Lang == "Russian" ? "Ğ¤Ğ Ğ¡" : "FED"
string _D_RATE   = i_Lang == "Arabic" ? "Ø§Ù„ÙØ§Ø¦Ø¯Ø©" : i_Lang == "Chinese" ? "åˆ©ç‡" : i_Lang == "Turkish" ? "Faiz" : i_Lang == "Russian" ? "Ğ¡Ñ‚Ğ°Ğ²ĞºĞ°" : "RATE"
string _D_DJI    = i_Lang == "Arabic" ? "Ø¯Ø§Ùˆ" : i_Lang == "Chinese" ? "é“æŒ‡" : i_Lang == "Turkish" ? "Dow" : i_Lang == "Russian" ? "Ğ”Ğ¾Ñƒ" : "DJI"
string _D_TASI   = i_Lang == "Arabic" ? "ØªØ§Ø³ÙŠ" : i_Lang == "Chinese" ? "æ²™ç‰¹" : i_Lang == "Turkish" ? "TASI" : i_Lang == "Russian" ? "Ğ¢ĞĞ¡Ğ˜" : "TASI"
string _D_EVENT  = i_Lang == "Arabic" ? "Ø­Ø¯Ø«" : i_Lang == "Chinese" ? "äº‹ä»¶" : i_Lang == "Turkish" ? "Olay" : i_Lang == "Russian" ? "Ğ¡Ğ¾Ğ±Ñ‹Ñ‚Ğ¸Ğµ" : "EVENT"
string _D_SAFE   = i_Lang == "Arabic" ? "Ø§Ù„Ø£Ù…Ø§Ù†" : i_Lang == "Chinese" ? "å®‰å…¨" : i_Lang == "Turkish" ? "GÃ¼venlik" : i_Lang == "Russian" ? "Ğ‘ĞµĞ·Ğ¾Ğ¿." : "SAFE"

// â”€â”€â”€ Sector Names â€” Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ù‚Ø·Ø§Ø¹Ø§Øª â”€â”€â”€
string _S_AI     = i_Lang == "Arabic" ? "Ø°ÙƒØ§Ø¡" : i_Lang == "Chinese" ? "AI" : i_Lang == "Turkish" ? "YZ" : i_Lang == "Russian" ? "Ğ˜Ğ˜" : "AI"
string _S_L1     = i_Lang == "Arabic" ? "Ø¨Ù†ÙŠØ©" : i_Lang == "Chinese" ? "L1" : i_Lang == "Turkish" ? "L1" : i_Lang == "Russian" ? "L1" : "L1"
string _S_MEME   = i_Lang == "Arabic" ? "Ù…ÙŠÙ…" : i_Lang == "Chinese" ? "æ¨¡å› " : i_Lang == "Turkish" ? "Meme" : i_Lang == "Russian" ? "ĞœĞµĞ¼" : "Meme"
string _S_RWA    = i_Lang == "Arabic" ? "Ø£ØµÙˆÙ„" : i_Lang == "Chinese" ? "RWA" : i_Lang == "Turkish" ? "RWA" : i_Lang == "Russian" ? "RWA" : "RWA"
string _S_DEFI   = i_Lang == "Arabic" ? "ØªÙ…ÙˆÙŠÙ„" : i_Lang == "Chinese" ? "DeFi" : i_Lang == "Turkish" ? "DeFi" : i_Lang == "Russian" ? "DeFi" : "DeFi"
string _S_ORAC   = i_Lang == "Arabic" ? "Ø£ÙˆØ±Ø§ÙƒÙ„" : i_Lang == "Chinese" ? "é¢„è¨€æœº" : i_Lang == "Turkish" ? "Oracle" : i_Lang == "Russian" ? "ĞÑ€Ğ°ĞºĞ»" : "Orac"
string _S_L2     = i_Lang == "Arabic" ? "Ø·Ø¨Ù‚Ø©Ù¢" : i_Lang == "Chinese" ? "L2" : i_Lang == "Turkish" ? "L2" : i_Lang == "Russian" ? "L2" : "L2"
string _S_GAME   = i_Lang == "Arabic" ? "Ø£Ù„Ø¹Ø§Ø¨" : i_Lang == "Chinese" ? "æ¸¸æˆ" : i_Lang == "Turkish" ? "Oyun" : i_Lang == "Russian" ? "Ğ˜Ğ³Ñ€Ñ‹" : "Game"

// â”€â”€â”€ Titan Names â€” Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø¹Ù…Ø§Ù„Ù‚Ø© â”€â”€â”€
string _T_ELON   = i_Lang == "Arabic" ? "Ø¥ÙŠÙ„ÙˆÙ†" : i_Lang == "Chinese" ? "é©¬æ–¯å…‹" : i_Lang == "Turkish" ? "Elon" : i_Lang == "Russian" ? "Ğ˜Ğ»Ğ¾Ğ½" : "Elon"
string _T_SAYLOR = i_Lang == "Arabic" ? "Ø³ÙŠÙ„ÙˆØ±" : i_Lang == "Chinese" ? "å¡å‹’" : i_Lang == "Turkish" ? "Saylor" : i_Lang == "Russian" ? "Ğ¡ÑĞ¹Ğ»Ğ¾Ñ€" : "Saylor"
string _T_BROCK  = i_Lang == "Arabic" ? "Ø¨Ù„Ø§ÙƒR" : i_Lang == "Chinese" ? "è´è±å¾·" : i_Lang == "Turkish" ? "BRock" : i_Lang == "Russian" ? "Ğ‘Ğ»ÑĞºĞ Ğ¾Ğº" : "BRock"
string _T_EXCH   = i_Lang == "Arabic" ? "Ø¨ÙˆØ±ØµØ§Øª" : i_Lang == "Chinese" ? "äº¤æ˜“æ‰€" : i_Lang == "Turkish" ? "Borsa" : i_Lang == "Russian" ? "Ğ‘Ğ¸Ñ€Ğ¶Ğ¸" : "Exch"

// â”€â”€â”€ Safety Status â€” Ø­Ø§Ù„Ø© Ø§Ù„Ø£Ù…Ø§Ù† â”€â”€â”€
string _SF_STABLE  = i_Lang == "Arabic" ? "Ù…Ø³ØªÙ‚Ø±" : i_Lang == "Chinese" ? "ç¨³å®š" : i_Lang == "Turkish" ? "Stabil" : i_Lang == "Russian" ? "Ğ¡Ñ‚Ğ°Ğ±Ğ¸Ğ»ÑŒĞ½Ğ¾" : "STABLE"
string _SF_CAUTION = i_Lang == "Arabic" ? "Ø­Ø°Ø±" : i_Lang == "Chinese" ? "è°¨æ…" : i_Lang == "Turkish" ? "Dikkat" : i_Lang == "Russian" ? "ĞÑÑ‚Ğ¾Ñ€Ğ¾Ğ¶Ğ½Ğ¾" : "CAUTION"
string _SF_DANGER  = i_Lang == "Arabic" ? "Ø®Ø·Ø±" : i_Lang == "Chinese" ? "å±é™©" : i_Lang == "Turkish" ? "Tehlike" : i_Lang == "Russian" ? "ĞĞ¿Ğ°ÑĞ½Ğ¾" : "DANGER"

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘              ğŸ”” SMART ALERTS V3 â€” Ø§Ù„ØªÙ‚Ø§Ø±ÙŠØ± Ø§Ù„Ø§Ø³ØªØ®Ø¨Ø§Ø±Ø§ØªÙŠØ©                                 â•‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€ V3 Alert Labels â€” ØªØ³Ù…ÙŠØ§Øª Ø§Ù„ØªÙ‚Ø±ÙŠØ± â”€â”€â”€
string _V3_TITLE     = i_Lang == "Arabic" ? "Ø§Ø³ØªØ®Ø¨Ø§Ø±Ø§Øª RZIN" : i_Lang == "Chinese" ? "RZINæƒ…æŠ¥" : i_Lang == "Turkish" ? "RZIN Ä°stihbarat" : i_Lang == "Russian" ? "RZIN Ğ Ğ°Ğ·Ğ²ĞµĞ´ĞºĞ°" : "RZIN INTEL"
string _V3_QUALITY   = i_Lang == "Arabic" ? "Ø§Ù„Ø¬ÙˆØ¯Ø©" : i_Lang == "Chinese" ? "è´¨é‡" : i_Lang == "Turkish" ? "Kalite" : i_Lang == "Russian" ? "ĞšĞ°Ñ‡ĞµÑÑ‚Ğ²Ğ¾" : "Quality"
string _V3_CONFIRM   = i_Lang == "Arabic" ? "Ø§Ù„ØªØ£ÙƒÙŠØ¯" : i_Lang == "Chinese" ? "ç¡®è®¤" : i_Lang == "Turkish" ? "Onay" : i_Lang == "Russian" ? "ĞŸĞ¾Ğ´Ñ‚Ğ²ĞµÑ€Ğ¶Ğ´." : "Confirm"
string _V3_PRICE     = i_Lang == "Arabic" ? "Ø§Ù„Ø³Ø¹Ø±" : i_Lang == "Chinese" ? "ä»·æ ¼" : i_Lang == "Turkish" ? "Fiyat" : i_Lang == "Russian" ? "Ğ¦ĞµĞ½Ğ°" : "Price"
string _V3_ENTRY     = i_Lang == "Arabic" ? "Ø§Ù„Ø¯Ø®ÙˆÙ„" : i_Lang == "Chinese" ? "å…¥åœº" : i_Lang == "Turkish" ? "GiriÅŸ" : i_Lang == "Russian" ? "Ğ’Ñ…Ğ¾Ğ´" : "Entry"
string _V3_SL        = i_Lang == "Arabic" ? "ÙˆÙ‚Ù" : i_Lang == "Chinese" ? "æ­¢æŸ" : i_Lang == "Turkish" ? "Stop" : i_Lang == "Russian" ? "Ğ¡Ñ‚Ğ¾Ğ¿" : "SL"
string _V3_TP        = i_Lang == "Arabic" ? "Ù‡Ø¯Ù" : i_Lang == "Chinese" ? "ç›®æ ‡" : i_Lang == "Turkish" ? "Hedef" : i_Lang == "Russian" ? "Ğ¦ĞµĞ»ÑŒ" : "TP"
string _V3_BULL      = i_Lang == "Arabic" ? "Ø´Ø±Ø§Ø¡" : i_Lang == "Chinese" ? "åšå¤š" : i_Lang == "Turkish" ? "AL" : i_Lang == "Russian" ? "Ğ›ĞĞĞ“" : "LONG"
string _V3_BEAR      = i_Lang == "Arabic" ? "Ø¨ÙŠØ¹" : i_Lang == "Chinese" ? "åšç©º" : i_Lang == "Turkish" ? "SAT" : i_Lang == "Russian" ? "Ğ¨ĞĞ Ğ¢" : "SHORT"
string _V3_VOL       = i_Lang == "Arabic" ? "Ø³ÙŠÙˆÙ„Ø© Ø¹Ø§Ù„ÙŠØ©" : i_Lang == "Chinese" ? "å¼ºæµåŠ¨" : i_Lang == "Turkish" ? "GÃ¼Ã§lÃ¼ Hacim" : i_Lang == "Russian" ? "Ğ¡Ğ¸Ğ»ÑŒĞ½.ĞĞ±ÑŠÑ‘Ğ¼" : "High Vol"
string _V3_DIV       = i_Lang == "Arabic" ? "Ø¯Ø§ÙŠÙØ±Ø¬Ù†Ø³" : i_Lang == "Chinese" ? "èƒŒç¦»" : i_Lang == "Turkish" ? "Diverjans" : i_Lang == "Russian" ? "Ğ”Ğ¸Ğ²ĞµÑ€Ğ³ĞµĞ½Ñ†Ğ¸Ñ" : "Divergence"
string _V3_TREND     = i_Lang == "Arabic" ? "Ù…Ø¹ Ø§Ù„Ø§ØªØ¬Ø§Ù‡" : i_Lang == "Chinese" ? "é¡ºåŠ¿" : i_Lang == "Turkish" ? "Trendli" : i_Lang == "Russian" ? "ĞŸĞ¾ Ñ‚Ñ€ĞµĞ½Ğ´Ñƒ" : "Trend OK"
string _V3_GHOST_LBL = i_Lang == "Arabic" ? "Ø§Ø³ØªØ¨Ø§Ù‚ÙŠ" : i_Lang == "Chinese" ? "é¢„åˆ¤" : i_Lang == "Turkish" ? "Ã–ncÃ¼" : i_Lang == "Russian" ? "ĞŸÑ€Ğ¾Ğ³Ğ½Ğ¾Ğ·" : "Forecast"
string _V3_COMPLETE  = i_Lang == "Arabic" ? "Ù…ÙƒØªÙ…Ù„" : i_Lang == "Chinese" ? "å®Œæˆ" : i_Lang == "Turkish" ? "Tamam" : i_Lang == "Russian" ? "Ğ—Ğ°Ğ²ĞµÑ€ÑˆÑ‘Ğ½" : "Complete"
string _V3_TGT_HIT   = i_Lang == "Arabic" ? "ØªØ­Ù‚Ù‚ Ø§Ù„Ù‡Ø¯Ù" : i_Lang == "Chinese" ? "ç›®æ ‡è¾¾æˆ" : i_Lang == "Turkish" ? "Hedefe Var." : i_Lang == "Russian" ? "Ğ¦ĞµĞ»ÑŒ Ğ´Ğ¾ÑÑ‚Ğ¸Ğ³." : "Target Hit"
string _V3_INVALID   = i_Lang == "Arabic" ? "ØªÙ… Ø§Ù„Ø¥Ø¨Ø·Ø§Ù„" : i_Lang == "Chinese" ? "å·²å¤±æ•ˆ" : i_Lang == "Turkish" ? "GeÃ§ersiz" : i_Lang == "Russian" ? "ĞĞ½Ğ½ÑƒĞ»Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½" : "Invalidated"
string _V3_SECTOR    = i_Lang == "Arabic" ? "ØªÙˆØ§ÙÙ‚ Ù‚Ø·Ø§Ø¹ÙŠ" : i_Lang == "Chinese" ? "æ¿å—åŒæ­¥" : i_Lang == "Turkish" ? "SektÃ¶r Uyumu" : i_Lang == "Russian" ? "Ğ¡ĞµĞºÑ‚Ğ¾Ñ€ Ğ¡Ğ¸Ğ½Ñ…Ñ€." : "Sector OK"
string _V3_SOV       = i_Lang == "Arabic" ? "ØªØ¶Ø§ÙØ± Ø³ÙŠØ§Ø¯ÙŠ" : i_Lang == "Chinese" ? "ä¸»æƒå…±æŒ¯" : i_Lang == "Turkish" ? "Egemenlik" : i_Lang == "Russian" ? "Ğ¡ÑƒĞ²ĞµÑ€ĞµĞ½Ğ½Ñ‹Ğ¹" : "Sovereign"
string _V3_RR        = i_Lang == "Arabic" ? "Ù…Ø®Ø§Ø·Ø±Ø©:Ø¹Ø§Ø¦Ø¯" : i_Lang == "Chinese" ? "é£é™©:æ”¶ç›Š" : i_Lang == "Turkish" ? "Risk:Ã–dÃ¼l" : i_Lang == "Russian" ? "Ğ Ğ¸ÑĞº:ĞŸÑ€Ğ¸Ğ±." : "R:R"

f_qGrade(int q) =>
    q >= 85 ? "S" : q >= 70 ? "A" : q >= 55 ? "B" : q >= 40 ? "C" : "D"

f_qBar(int q) =>
    q >= 85 ? "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ" : q >= 70 ? "â–ˆâ–ˆâ–ˆâ–ˆâ–‘" : q >= 55 ? "â–ˆâ–ˆâ–ˆâ–‘â–‘" : q >= 40 ? "â–ˆâ–ˆâ–‘â–‘â–‘" : "â–ˆâ–‘â–‘â–‘â–‘"

// â”€â”€â”€ Ø£Ø¹Ù„Ø§Ù… Ø¹Ø§Ù„Ù…ÙŠØ© Ù„Ù€ alertcondition â”€â”€â”€
var bool _acComplete   = false
var bool _acGhost      = false
var bool _acSector     = false
var bool _acLiquidity  = false
var bool _acTarget     = false
var bool _acProtect    = false
_acComplete   := false
_acGhost      := false
_acSector     := false
_acLiquidity  := false
_acTarget     := false
_acProtect    := false

f_sector_aligned(bool isBull) =>
    int votes = 0
    if isBull
        votes += nz(_btcC) > 0 ? 1 : 0
        votes += nz(_ethC) > 0 ? 1 : 0
        votes += nz(_totC) > 0 ? 1 : 0
    else
        votes += nz(_btcC) < 0 ? 1 : 0
        votes += nz(_ethC) < 0 ? 1 : 0
        votes += nz(_totC) < 0 ? 1 : 0
    votes >= 2

float _volAvg = ta.sma(volume, 20)
bool _volSpike = volume > (_volAvg * 1.5)

bool _sovBullOk = (nz(_dxyC) < 0 and (nz(_walclC) > 0 or nz(_vix) < 20))
bool _sovBearOk = (nz(_dxyC) > 0 and (nz(_walclC) < 0 or nz(_vix) > 25))
bool _acSovereign = false
string _L_SOVEREIGN = i_Lang == "Arabic" ? "ØªØ¶Ø§ÙØ± Ø³ÙŠØ§Ø¯ÙŠ" : i_Lang == "Chinese" ? "ä¸»æƒå…±æŒ¯" : i_Lang == "Turkish" ? "Egemenlik Sinyali" : i_Lang == "Russian" ? "Ğ¡ÑƒĞ²ĞµÑ€ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ¡Ğ¸Ğ³Ğ½Ğ°Ğ»" : "Data Synergy"

if barstate.isconfirmed and i_EnableAlerts
    int sz = array.size(patterns)
    if sz > 0
        for i = 0 to math.min(sz - 1, 9)
            Pattern p = array.get(patterns, i)
            string sym = syminfo.ticker
            string tf  = timeframe.period
            string dir = p.isBull ? _V3_BULL : _V3_BEAR
            string pName = f_patName(p.name)
            // â”€â”€â”€ Quality Score â”€â”€â”€
            [qScore, qDiv, qVol, qTrend] = f_qualityScore(p.name, p.isBull, p.rXAB, p.rABC, p.rXAD, p.bX, p.bA, p.bB, p.bC, p.bD, p.pX, p.pD)
            string grade = f_qGrade(qScore)
            string qBar = f_qBar(qScore)
            // â”€â”€â”€ TP/SL â”€â”€â”€
            [tp1v, tp2v] = calc_TP_Levels(p.pC, p.pD, i_TP1_R, i_TP2_R)
            float slP = p.pX
            float riskA = math.abs(p.pD - slP)
            float rewA = not na(tp1v) ? math.abs(tp1v - p.pD) : 0.0
            string rrTxt = riskA > 0 ? "1:" + str.tostring(rewA / riskA, "#.#") : "â€”"
            // â”€â”€â”€ Ù…Ù„Ø§Ø­Ø¸Ø§Øª â”€â”€â”€
            string notes = ""
            if qVol
                notes := _V3_VOL
            if qDiv
                notes += (notes != "" ? " | " : "") + _V3_DIV
            if qTrend
                notes += (notes != "" ? " | " : "") + _V3_TREND
            bool sectorOk = f_sector_aligned(p.isBull)
            if sectorOk
                notes += (notes != "" ? " | " : "") + _V3_SECTOR
            bool sovOk = (p.isBull and _sovBullOk) or (not p.isBull and _sovBearOk)
            if sovOk
                notes += (notes != "" ? " | " : "") + _V3_SOV
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // 1. Ù†Ù…Ø· Ù…ÙƒØªÙ…Ù„ â€” Ø§Ù„ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ø§Ø³ØªØ®Ø¨Ø§Ø±Ø§ØªÙŠ Ø§Ù„ÙƒØ§Ù…Ù„
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if not p.isGhost and not p.alertedNew
                if qScore >= i_QualityMin
                    string m = "âš¡ " + _V3_TITLE + "\n"
                    m += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                    m += pName + " " + dir + " | " + sym + " " + tf + "\n"
                    m += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                    m += _V3_QUALITY + ": " + str.tostring(qScore) + "% [" + grade + "] " + qBar + "\n"
                    m += _V3_CONFIRM + ": " + _V3_COMPLETE + "\n"
                    m += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                    m += _V3_ENTRY + ": " + str.tostring(p.pD, "#.####") + "\n"
                    m += _V3_SL + ": " + str.tostring(slP, "#.####") + "\n"
                    m += _V3_TP + "1: " + (na(tp1v) ? "â€”" : str.tostring(tp1v, "#.####")) + "\n"
                    m += _V3_TP + "2: " + (na(tp2v) ? "â€”" : str.tostring(tp2v, "#.####")) + "\n"
                    m += _V3_RR + ": " + rrTxt + "\n"
                    if notes != ""
                        m += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                        m += notes + "\n"
                    m += "\nâ¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯\n" + _L_DISC + "\nSAUDI ARABIA"
                    alert(m, alert.freq_once_per_bar_close)
                    _acComplete := true
                    if sectorOk
                        _acSector := true
                    if _volSpike
                        _acLiquidity := true
                    if sovOk
                        _acSovereign := true
                p.alertedNew := true
                array.set(patterns, i, p)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // 2. Ø§Ø³ØªØ¨Ø§Ù‚ÙŠ â€” ØªÙ‚Ø±ÙŠØ± Ù…Ø®ØªØµØ±
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if p.isGhost and not p.alertedNew
                int quality = 0
                if _gq_volOk
                    quality += 1
                if (p.isBull and _gq_zScore <= -i_ZScoreMin) or (not p.isBull and _gq_zScore >= i_ZScoreMin)
                    quality += 1
                if p.bX > 0 and p.bX < bar_index
                    int _alb = bar_index - p.bX
                    if _alb < math.min(500, bar_index)
                        if p.isBull
                            if close < p.pX and rsiVal > rsiVal[_alb]
                                quality += 1
                        else
                            if close > p.pX and rsiVal < rsiVal[_alb]
                                quality += 1
                if quality >= 2
                    string stars = quality == 3 ? "â˜…â˜…â˜…" : "â˜…â˜…"
                    string m = "ğŸ‘» " + _V3_TITLE + "\n"
                    m += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                    m += pName + " " + dir + " " + stars + "\n"
                    m += sym + " " + tf + "\n"
                    m += _V3_CONFIRM + ": " + _V3_GHOST_LBL + "\n"
                    m += _V3_ENTRY + " D: " + str.tostring(p.pD, "#.####") + "\n"
                    m += _V3_PRICE + ": " + str.tostring(close, "#.####") + "\n"
                    m += "\nâ¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯\n" + _L_DISC + "\nSAUDI ARABIA"
                    alert(m, alert.freq_once_per_bar_close)
                    p.alertedNew := true
                    _acGhost := true
                    array.set(patterns, i, p)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // 3. Ø£Ù‡Ø¯Ø§Ù
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if not p.isGhost
                [tp1c, tp2c] = calc_TP_Levels(p.pC, p.pD, i_TP1_R, i_TP2_R)
                bool hTP1 = not na(tp1c) and (p.isBull ? close >= tp1c : close <= tp1c)
                bool hTP2 = not na(tp2c) and (p.isBull ? close >= tp2c : close <= tp2c)
                if hTP1 and not p.alertedTP1
                    string m = "ğŸ¯ " + _V3_TGT_HIT + " â‘ \n"
                    m += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                    m += pName + " " + dir + " | " + sym + " " + tf + "\n"
                    m += _V3_TP + "1: " + str.tostring(tp1c, "#.####") + "\n"
                    m += _V3_PRICE + ": " + str.tostring(close, "#.####") + "\n"
                    m += "\nâ¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯\n" + _L_DISC + "\nSAUDI ARABIA"
                    alert(m, alert.freq_once_per_bar_close)
                    p.alertedTP1 := true
                    _acTarget := true
                    array.set(patterns, i, p)
                if hTP2 and not p.alertedTP2
                    string m = "ğŸ† " + _V3_TGT_HIT + " â‘¡\n"
                    m += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                    m += pName + " " + dir + " | " + sym + " " + tf + "\n"
                    m += _V3_TP + "2: " + str.tostring(tp2c, "#.####") + "\n"
                    m += _V3_PRICE + ": " + str.tostring(close, "#.####") + "\n"
                    m += "\nâ¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯\n" + _L_DISC + "\nSAUDI ARABIA"
                    alert(m, alert.freq_once_per_bar_close)
                    p.alertedTP2 := true
                    _acTarget := true
                    array.set(patterns, i, p)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // 4. Ø­Ù…Ø§ÙŠØ©
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if not p.isGhost and not p.alertedSL
                bool broken = p.isBull ? close < p.pX : close > p.pX
                if broken
                    string m = "ğŸš¨ " + _V3_INVALID + "\n"
                    m += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                    m += pName + " " + dir + " | " + sym + " " + tf + "\n"
                    m += _V3_SL + " X: " + str.tostring(p.pX, "#.####") + "\n"
                    m += _V3_PRICE + ": " + str.tostring(close, "#.####") + "\n"
                    m += "\nâ¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯â¯\n" + _L_DISC + "\nSAUDI ARABIA"
                    alert(m, alert.freq_once_per_bar_close)
                    p.alertedSL := true
                    _acProtect := true
                    array.set(patterns, i, p)

// Ø¨ÙˆØ§Ø¨Ø§Øª alertcondition â€” Ù…Ø³Ù…ÙŠØ§Øª Ø¹Ø§Ù„Ù…ÙŠØ©
alertcondition(_acComplete,  title="âš¡ RZIN Structure",   message="Pattern structure confirmed â€” check RZIN alert for full intelligence report")
alertcondition(_acSector,    title="ğŸ“¡ Sector Sync",      message="Sector alignment confirmed â€” harmonic + market sync")
alertcondition(_acLiquidity, title="ğŸ’§ Liquidity",        message="Volume spike at harmonic zone")
alertcondition(_acGhost,     title="ğŸ‘» Ghost Signal",     message="Emerging structure detected â€” quality sensors active")
alertcondition(_acTarget,    title="ğŸ¯ Target Hit",       message="Take profit level reached")
alertcondition(_acProtect,   title="ğŸš¨ Invalidated",      message="Stop level breached â€” pattern invalidated")
alertcondition(_acComplete and (_sovBullOk or _sovBearOk), title="ğŸ›ï¸ Data Synergy", message="Harmonic + favorable macro alignment")

// â”€â”€â”€ Ø§Ù„ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø°Ø§ØªÙŠ Ø¨Ø¹Ø¯ Ø§Ù„ØªÙ†Ø¨ÙŠÙ‡Ø§Øª â”€â”€â”€
if barstate.isconfirmed
    cleanStale()

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘              [20] ğŸ“¡ INTEL RADAR HUD â€” Ø±Ø§Ø¯Ø§Ø± Ø§Ø³ØªØ®Ø¨Ø§Ø±Ø§Øª Ø§Ù„Ø³ÙˆÙ‚                               â•‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€ Ø£Ø­Ø¯Ø§Ø« 2026 Ø§Ù„ÙƒØ¨Ø±Ù‰ (FOMC + CPI + NFP) â”€â”€â”€
f_next_event() =>
    var array<int> eDates = array.new_int()
    var array<string> eNames = array.new_string()
    var bool _init = false
    if not _init
        // FOMC 2026
        array.push(eDates, timestamp(2026,01,29,18,0)), array.push(eNames, "FOMC")
        array.push(eDates, timestamp(2026,03,19,18,0)), array.push(eNames, "FOMC")
        array.push(eDates, timestamp(2026,05,07,18,0)), array.push(eNames, "FOMC")
        array.push(eDates, timestamp(2026,06,18,18,0)), array.push(eNames, "FOMC")
        array.push(eDates, timestamp(2026,07,30,18,0)), array.push(eNames, "FOMC")
        array.push(eDates, timestamp(2026,09,17,18,0)), array.push(eNames, "FOMC")
        array.push(eDates, timestamp(2026,11,05,18,0)), array.push(eNames, "FOMC")
        array.push(eDates, timestamp(2026,12,17,18,0)), array.push(eNames, "FOMC")
        // CPI 2026
        array.push(eDates, timestamp(2026,01,14,12,30)), array.push(eNames, "CPI")
        array.push(eDates, timestamp(2026,02,11,12,30)), array.push(eNames, "CPI")
        array.push(eDates, timestamp(2026,03,11,12,30)), array.push(eNames, "CPI")
        array.push(eDates, timestamp(2026,04,14,12,30)), array.push(eNames, "CPI")
        array.push(eDates, timestamp(2026,05,12,12,30)), array.push(eNames, "CPI")
        array.push(eDates, timestamp(2026,06,10,12,30)), array.push(eNames, "CPI")
        array.push(eDates, timestamp(2026,07,14,12,30)), array.push(eNames, "CPI")
        array.push(eDates, timestamp(2026,08,12,12,30)), array.push(eNames, "CPI")
        array.push(eDates, timestamp(2026,09,11,12,30)), array.push(eNames, "CPI")
        array.push(eDates, timestamp(2026,10,13,12,30)), array.push(eNames, "CPI")
        array.push(eDates, timestamp(2026,11,12,12,30)), array.push(eNames, "CPI")
        array.push(eDates, timestamp(2026,12,10,12,30)), array.push(eNames, "CPI")
        // NFP 2026
        array.push(eDates, timestamp(2026,01,09,12,30)), array.push(eNames, "NFP")
        array.push(eDates, timestamp(2026,02,06,12,30)), array.push(eNames, "NFP")
        array.push(eDates, timestamp(2026,03,06,12,30)), array.push(eNames, "NFP")
        array.push(eDates, timestamp(2026,04,03,12,30)), array.push(eNames, "NFP")
        array.push(eDates, timestamp(2026,05,08,12,30)), array.push(eNames, "NFP")
        array.push(eDates, timestamp(2026,06,05,12,30)), array.push(eNames, "NFP")
        array.push(eDates, timestamp(2026,07,02,12,30)), array.push(eNames, "NFP")
        array.push(eDates, timestamp(2026,08,07,12,30)), array.push(eNames, "NFP")
        array.push(eDates, timestamp(2026,09,04,12,30)), array.push(eNames, "NFP")
        array.push(eDates, timestamp(2026,10,02,12,30)), array.push(eNames, "NFP")
        array.push(eDates, timestamp(2026,11,06,12,30)), array.push(eNames, "NFP")
        array.push(eDates, timestamp(2026,12,04,12,30)), array.push(eNames, "NFP")
        _init := true
    string nextName = "â€”"
    int nextMs = 999999999999999
    int nowMs = timenow
    int eSz = array.size(eDates)
    if eSz > 0
        for j = 0 to eSz - 1
            int dt = array.get(eDates, j)
            if dt > nowMs and dt < nextMs
                nextMs := dt
                nextName := array.get(eNames, j)
    float minsLeft = (nextMs - nowMs) / 60000.0
    [nextName, minsLeft]


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘              ğŸ“¡ RZIN SOVEREIGN V7 â€” Intelligence Command Center                          â•‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

f_a(float c) => na(c) ? "â€”" : nz(c) >= 0 ? "â–²" : "â–¼"
f_c(float c) => na(c) ? #b8b8b8 : nz(c) >= 0 ? #26A69A : #EF5350

// â”€â”€â”€ Sector Voting: 2-of-2 majority color â”€â”€â”€
f_sv(float a, float b) =>
    int up = 0
    if nz(a) > 0
        up += 1
    if nz(b) > 0
        up += 1
    up >= 1 ? (up == 2 ? #26A69A : #b8b8b8) : #EF5350

// â”€â”€â”€ Titan Basket: average of basket components â”€â”€â”€
float _elonAvg   = (nz(_tslaC) + nz(_djiC)) / 2.0
float _saylorAvg = (nz(_mstrC) + nz(_maraC)) / 2.0
float _blkAvg    = (nz(_blkC) + nz(_ibitC)) / 2.0
float _exchAvg   = nz(_coinC)

var table hud = table.new(position.top_right, 2, 40, bgcolor=color.new(color.black, 85), border_width=0)

if barstate.islast and i_MasterHUD
    int r = 0

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ§­ (A) THE MARKET CORE â€” Ø§Ù„ÙƒØ±ÙŠØ¨ØªÙˆ ÙˆØ§Ù„Ø§Ø³ØªØ­ÙˆØ§Ø°
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if u_liq
        // â”€â”€â”€ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± â”€â”€â”€
        table.cell(hud, 0, r, "BTC", text_color=#b8b8b8, text_size=size.tiny, text_halign=text.align_left, text_font_family=font.family_monospace)
        table.cell(hud, 1, r, str.tostring(_btcP, "#") + " " + f_a(_btcC), text_color=f_c(_btcC), text_size=size.tiny, text_halign=text.align_right, text_font_family=font.family_monospace)
        r += 1
        table.cell(hud, 0, r, "ETH", text_color=#b8b8b8, text_size=size.tiny, text_halign=text.align_left, text_font_family=font.family_monospace)
        table.cell(hud, 1, r, str.tostring(_ethP, "#") + " " + f_a(_ethC), text_color=f_c(_ethC), text_size=size.tiny, text_halign=text.align_right, text_font_family=font.family_monospace)
        r += 1
        // â”€â”€â”€ Ø§Ù„Ù‡ÙŠÙ…Ù†Ø© â”€â”€â”€
        table.cell(hud, 0, r, _D_BTCD, text_color=#b8b8b8, text_size=size.tiny, text_halign=text.align_left, text_font_family=font.family_monospace)
        table.cell(hud, 1, r, str.tostring(_btcD, "#.#") + "% " + f_a(_btcDC), text_color=f_c(_btcDC), text_size=size.tiny, text_halign=text.align_right, text_font_family=font.family_monospace)
        r += 1
        table.cell(hud, 0, r, _D_ETHD, text_color=#b8b8b8, text_size=size.tiny, text_halign=text.align_left, text_font_family=font.family_monospace)
        table.cell(hud, 1, r, na(_ethD) ? "â€”" : str.tostring(_ethD, "#.#") + "% " + f_a(_ethDC), text_color=na(_ethD) ? #b8b8b8 : f_c(_ethDC), text_size=size.tiny, text_halign=text.align_right, text_font_family=font.family_monospace)
        r += 1
        table.cell(hud, 0, r, _D_OTHD, text_color=#b8b8b8, text_size=size.tiny, text_halign=text.align_left, text_font_family=font.family_monospace)
        table.cell(hud, 1, r, na(_othD) ? "â€”" : str.tostring(_othD, "#.#") + "% " + f_a(_othDC), text_color=na(_othD) ? #b8b8b8 : f_c(_othDC), text_size=size.tiny, text_halign=text.align_right, text_font_family=font.family_monospace)
        r += 1
        // USDT.D â€” ØªÙ„ÙˆÙŠÙ† Ø¹ÙƒØ³ÙŠ (Ù‡Ø¨ÙˆØ·Ù‡ Ø¥ÙŠØ¬Ø§Ø¨ÙŠ)
        table.cell(hud, 0, r, _D_USDTD, text_color=#b8b8b8, text_size=size.tiny, text_halign=text.align_left, text_font_family=font.family_monospace)
        table.cell(hud, 1, r, na(_usdtD) ? "â€”" : str.tostring(_usdtD, "#.##") + "% " + f_a(_usdtDC), text_color=na(_usdtDC) ? #b8b8b8 : f_c(-nz(_usdtDC)), text_size=size.tiny, text_halign=text.align_right, text_font_family=font.family_monospace)
        r += 1
        // â”€â”€â”€ Ø§Ù„Ø³ÙŠÙˆÙ„Ø© Ø§Ù„ÙƒÙ„ÙŠØ© â”€â”€â”€
        table.cell(hud, 0, r, _D_TOTAL, text_color=#b8b8b8, text_size=size.tiny, text_halign=text.align_left, text_font_family=font.family_monospace)
        table.cell(hud, 1, r, str.tostring(_total / 1e12, "#.##") + "T " + f_a(_totC), text_color=f_c(_totC), text_size=size.tiny, text_halign=text.align_right, text_font_family=font.family_monospace)
        r += 1
        table.cell(hud, 0, r, _D_TOT2, text_color=#b8b8b8, text_size=size.tiny, text_halign=text.align_left, text_font_family=font.family_monospace)
        table.cell(hud, 1, r, na(_tot2) ? "â€”" : str.tostring(_tot2 / 1e12, "#.##") + "T " + f_a(_tot2C), text_color=na(_tot2) ? #b8b8b8 : f_c(_tot2C), text_size=size.tiny, text_halign=text.align_right, text_font_family=font.family_monospace)
        r += 1
        table.cell(hud, 0, r, _D_TOT3, text_color=#b8b8b8, text_size=size.tiny, text_halign=text.align_left, text_font_family=font.family_monospace)
        table.cell(hud, 1, r, na(_tot3) ? "â€”" : str.tostring(_tot3 / 1e12, "#.##") + "T " + f_a(_tot3C), text_color=na(_tot3) ? #b8b8b8 : f_c(_tot3C), text_size=size.tiny, text_halign=text.align_right, text_font_family=font.family_monospace)
        r += 1
        // â”€â”€â”€ Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„ØµØ­Ø© â”€â”€â”€
        table.cell(hud, 0, r, _D_BO, text_color=#b8b8b8, text_size=size.tiny, text_halign=text.align_left, text_font_family=font.family_monospace)
        table.cell(hud, 1, r, na(_btcOth) ? "â€”" : str.tostring(_btcOth, "#.#") + " " + f_a(_btcOthC), text_color=na(_btcOth) ? #b8b8b8 : f_c(_btcOthC), text_size=size.tiny, text_halign=text.align_right, text_font_family=font.family_monospace)
        r += 1
        table.cell(hud, 0, r, _D_SSR, text_color=#b8b8b8, text_size=size.tiny, text_halign=text.align_left, text_font_family=font.family_monospace)
        table.cell(hud, 1, r, na(_ssr) ? "â€”" : str.tostring(_ssr, "#.#") + " " + f_a(_ssrC), text_color=na(_ssr) ? #b8b8b8 : f_c(_ssrC), text_size=size.tiny, text_halign=text.align_right, text_font_family=font.family_monospace)
        r += 1

    // â”€â”€â”€ ÙØ§ØµÙ„ â”€â”€â”€
    if u_liq and u_sectors
        table.cell(hud, 0, r, "â”€â”€â”€â”€â”€", text_color=#3d4a57, text_size=size.tiny, text_halign=text.align_left, text_font_family=font.family_monospace)
        table.cell(hud, 1, r, "â”€â”€â”€â”€â”€", text_color=#3d4a57, text_size=size.tiny, text_halign=text.align_right, text_font_family=font.family_monospace)
        r += 1

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ“¡ (B) SECTOR RADAR â€” Ø±Ø§Ø¯Ø§Ø± Ø§Ù„Ù‚Ø·Ø§Ø¹Ø§Øª (2-of-2 Voting)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if u_sectors
        // ÙƒÙ„ Ù‚Ø·Ø§Ø¹ ÙÙŠ Ø³Ø·Ø± ÙˆØ§Ø­Ø¯ â€” Ø§Ù„Ù„ÙˆÙ† ÙŠØªØ­Ø¯Ø¯ Ø¨Ø§Ù„Ø£ØºÙ„Ø¨ÙŠØ© (2 of 2)
        table.cell(hud, 0, r, _S_AI, text_color=f_sv(_fetC, _rndrC), text_size=size.tiny, text_halign=text.align_left, text_font_family=font.family_monospace)
        table.cell(hud, 1, r, _S_L1, text_color=f_sv(_solC, _ethC), text_size=size.tiny, text_halign=text.align_right, text_font_family=font.family_monospace)
        r += 1
        table.cell(hud, 0, r, _S_MEME, text_color=f_sv(_dogeC, _pepeC), text_size=size.tiny, text_halign=text.align_left, text_font_family=font.family_monospace)
        table.cell(hud, 1, r, _S_RWA, text_color=f_sv(_ondoC, _ondoC), text_size=size.tiny, text_halign=text.align_right, text_font_family=font.family_monospace)
        r += 1
        table.cell(hud, 0, r, _S_DEFI, text_color=f_sv(_aaveC, _uniC), text_size=size.tiny, text_halign=text.align_left, text_font_family=font.family_monospace)
        table.cell(hud, 1, r, _S_ORAC, text_color=f_sv(_linkC, _linkC), text_size=size.tiny, text_halign=text.align_right, text_font_family=font.family_monospace)
        r += 1
        table.cell(hud, 0, r, _S_L2, text_color=f_sv(_arbC, _arbC), text_size=size.tiny, text_halign=text.align_left, text_font_family=font.family_monospace)
        table.cell(hud, 1, r, _S_GAME, text_color=f_sv(_imxC, _imxC), text_size=size.tiny, text_halign=text.align_right, text_font_family=font.family_monospace)
        r += 1

    // â”€â”€â”€ ÙØ§ØµÙ„ â”€â”€â”€
    if u_sectors and u_titans
        table.cell(hud, 0, r, "â”€â”€â”€â”€â”€", text_color=#3d4a57, text_size=size.tiny, text_halign=text.align_left, text_font_family=font.family_monospace)
        table.cell(hud, 1, r, "â”€â”€â”€â”€â”€", text_color=#3d4a57, text_size=size.tiny, text_halign=text.align_right, text_font_family=font.family_monospace)
        r += 1

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ‹ (C) TITANS' EMPIRES â€” Ø¥Ù…Ø¨Ø±Ø§Ø·ÙˆØ±ÙŠØ§Øª Ø§Ù„Ø¹Ù…Ø§Ù„Ù‚Ø© (Basket)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if u_titans
        // Elon: avg(TSLA, DJI proxy) | Saylor: avg(MSTR, MARA)
        table.cell(hud, 0, r, _T_ELON + " " + f_a(_elonAvg), text_color=f_c(_elonAvg), text_size=size.tiny, text_halign=text.align_left, text_font_family=font.family_monospace)
        table.cell(hud, 1, r, _T_SAYLOR + " " + f_a(_saylorAvg), text_color=f_c(_saylorAvg), text_size=size.tiny, text_halign=text.align_right, text_font_family=font.family_monospace)
        r += 1
        // BlackRock: avg(BLK, IBIT) | Exchanges: COIN
        table.cell(hud, 0, r, _T_BROCK + " " + f_a(_blkAvg), text_color=f_c(_blkAvg), text_size=size.tiny, text_halign=text.align_left, text_font_family=font.family_monospace)
        table.cell(hud, 1, r, _T_EXCH + " " + f_a(_exchAvg), text_color=f_c(_exchAvg), text_size=size.tiny, text_halign=text.align_right, text_font_family=font.family_monospace)
        r += 1

    // â”€â”€â”€ ÙØ§ØµÙ„ â”€â”€â”€
    if (u_liq or u_sectors or u_titans) and (u_macro or u_sov or u_oil)
        table.cell(hud, 0, r, "â”€â”€â”€â”€â”€", text_color=#3d4a57, text_size=size.tiny, text_halign=text.align_left, text_font_family=font.family_monospace)
        table.cell(hud, 1, r, "â”€â”€â”€â”€â”€", text_color=#3d4a57, text_size=size.tiny, text_halign=text.align_right, text_font_family=font.family_monospace)
        r += 1

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸ§  (D) MACRO & PSYCHOLOGY â€” Ø§Ù„Ù…Ø§ÙƒØ±Ùˆ ÙˆØ§Ù„Ù†ÙØ³ÙŠØ©
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if u_macro
        float vx = nz(_vix)
        color vxC = vx > 30 ? #EF5350 : vx > 20 ? #FFA726 : #26A69A
        table.cell(hud, 0, r, "VIX", text_color=#b8b8b8, text_size=size.tiny, text_halign=text.align_left, text_font_family=font.family_monospace)
        table.cell(hud, 1, r, str.tostring(vx, "#.#"), text_color=vxC, text_size=size.tiny, text_halign=text.align_right, text_font_family=font.family_monospace)
        r += 1
        table.cell(hud, 0, r, _D_DXY, text_color=#b8b8b8, text_size=size.tiny, text_halign=text.align_left, text_font_family=font.family_monospace)
        table.cell(hud, 1, r, str.tostring(_dxy, "#.#") + " " + f_a(-nz(_dxyC)), text_color=f_c(-nz(_dxyC)), text_size=size.tiny, text_halign=text.align_right, text_font_family=font.family_monospace)
        r += 1
        table.cell(hud, 0, r, _D_GOLD, text_color=#b8b8b8, text_size=size.tiny, text_halign=text.align_left, text_font_family=font.family_monospace)
        table.cell(hud, 1, r, str.tostring(_gold, "#") + " " + f_a(_goldC), text_color=f_c(_goldC), text_size=size.tiny, text_halign=text.align_right, text_font_family=font.family_monospace)
        r += 1

    // â•â•â• Ø§Ù„Ù†ÙØ· â•â•â•
    if u_oil
        table.cell(hud, 0, r, _D_OIL_W, text_color=#b8b8b8, text_size=size.tiny, text_halign=text.align_left, text_font_family=font.family_monospace)
        table.cell(hud, 1, r, na(_wti) ? "â€”" : str.tostring(_wti, "#.#") + " " + f_a(_wtiC), text_color=na(_wti) ? #b8b8b8 : f_c(_wtiC), text_size=size.tiny, text_halign=text.align_right, text_font_family=font.family_monospace)
        r += 1
        table.cell(hud, 0, r, _D_OIL_B, text_color=#b8b8b8, text_size=size.tiny, text_halign=text.align_left, text_font_family=font.family_monospace)
        table.cell(hud, 1, r, na(_brent) ? "â€”" : str.tostring(_brent, "#.#") + " " + f_a(_brentC), text_color=na(_brent) ? #b8b8b8 : f_c(_brentC), text_size=size.tiny, text_halign=text.align_right, text_font_family=font.family_monospace)
        r += 1

    // â•â•â• Ø§Ù„Ø³ÙŠØ§Ø¯Ø© â•â•â•
    if u_sov
        table.cell(hud, 0, r, _D_FED, text_color=#b8b8b8, text_size=size.tiny, text_halign=text.align_left, text_font_family=font.family_monospace)
        if na(_walcl)
            table.cell(hud, 1, r, "â€”", text_color=#b8b8b8, text_size=size.tiny, text_halign=text.align_right, text_font_family=font.family_monospace)
        else
            float _fv = _walcl > 1000000000.0 ? _walcl / 1000000000000.0 : _walcl > 1000.0 ? _walcl / 1000000.0 : _walcl
            table.cell(hud, 1, r, str.tostring(_fv, "#.0") + "T " + f_a(_walclC), text_color=#26A69A, text_size=size.tiny, text_halign=text.align_right, text_font_family=font.family_monospace)
        r += 1
        table.cell(hud, 0, r, _D_RATE, text_color=#b8b8b8, text_size=size.tiny, text_halign=text.align_left, text_font_family=font.family_monospace)
        table.cell(hud, 1, r, na(_usir) ? "â€”" : str.tostring(_usir, "#.##") + "% " + f_a(-nz(_usirC)), text_color=na(_usir) ? #b8b8b8 : f_c(-nz(_usirC)), text_size=size.tiny, text_halign=text.align_right, text_font_family=font.family_monospace)
        r += 1

    // â•â•â• Ø§Ù„Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„Ø¹Ø§Ù„Ù…ÙŠØ© â•â•â•
    if u_macro
        table.cell(hud, 0, r, _D_DJI, text_color=#b8b8b8, text_size=size.tiny, text_halign=text.align_left, text_font_family=font.family_monospace)
        table.cell(hud, 1, r, na(_dji) ? "â€”" : str.tostring(_dji, "#") + " " + f_a(_djiC), text_color=na(_dji) ? #b8b8b8 : f_c(_djiC), text_size=size.tiny, text_halign=text.align_right, text_font_family=font.family_monospace)
        r += 1
        table.cell(hud, 0, r, _D_TASI, text_color=#b8b8b8, text_size=size.tiny, text_halign=text.align_left, text_font_family=font.family_monospace)
        table.cell(hud, 1, r, na(_tasi) ? "â€”" : str.tostring(_tasi, "#") + " " + f_a(_tasiC), text_color=na(_tasi) ? #b8b8b8 : f_c(_tasiC), text_size=size.tiny, text_halign=text.align_right, text_font_family=font.family_monospace)
        r += 1

    // â”€â”€â”€ ÙØ§ØµÙ„ â”€â”€â”€
    if u_sys
        table.cell(hud, 0, r, "â”€â”€â”€â”€â”€", text_color=#3d4a57, text_size=size.tiny, text_halign=text.align_left, text_font_family=font.family_monospace)
        table.cell(hud, 1, r, "â”€â”€â”€â”€â”€", text_color=#3d4a57, text_size=size.tiny, text_halign=text.align_right, text_font_family=font.family_monospace)
        r += 1

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ğŸš¨ SYSTEM â€” Ø§Ù„Ø£Ø­Ø¯Ø§Ø« ÙˆØ§Ù„Ø·ÙˆØ§Ø±Ø¦
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if u_sys
        [evN, evM] = f_next_event()
        float evD = evM / 60.0 / 24.0
        string evT = evM <= 60 ? evN + " " + str.tostring(evM, "#") + "m" : evD <= 3 ? evN + " " + str.tostring(evD, "#.#") + "d" : evN + " " + str.tostring(evD, "#") + "d"
        color evC = evM <= 60 ? #EF5350 : evD <= 3 ? #FFA726 : #b8b8b8
        table.cell(hud, 0, r, _D_EVENT, text_color=#FFA726, text_size=size.tiny, text_halign=text.align_left, text_font_family=font.family_monospace)
        table.cell(hud, 1, r, evT, text_color=evC, text_size=size.tiny, text_halign=text.align_right, text_font_family=font.family_monospace)
        r += 1
        float vs = nz(_vix)
        float ds = math.abs(nz(_dxyC))
        string sf = vs > 35 or ds > 1.5 ? _SF_DANGER : vs > 25 or ds > 1.0 ? _SF_CAUTION : _SF_STABLE
        color sc = vs > 35 or ds > 1.5 ? #EF5350 : vs > 25 or ds > 1.0 ? #FFA726 : #26A69A
        table.cell(hud, 0, r, _D_SAFE, text_color=#FFA726, text_size=size.tiny, text_halign=text.align_left, text_font_family=font.family_monospace)
        table.cell(hud, 1, r, sf, text_color=sc, text_size=size.tiny, text_halign=text.align_right, text_font_family=font.family_monospace)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â•‘              [21] ğŸ‡¸ğŸ‡¦ THE ROYAL STAMP â€” ÙŠØªØ¨Ø¹ Master HUD                                    â•‘
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var table rzin_stamp = table.new(position.bottom_right, 1, 2, bgcolor=color.new(color.black, 100), border_width=0)
if barstate.islast and i_MasterHUD
    color engraved = color.new(#92b6a9, 1)
    table.cell(rzin_stamp, 0, 0, "#Saudi_Vision2030", text_color=engraved, text_size=size.tiny, text_halign=text.align_right, text_font_family=font.family_monospace)
    table.cell(rzin_stamp, 0, 1, "ğ• Rzin_Bitcoin ", text_color=engraved, text_size=size.tiny, text_halign=text.align_right, text_font_family=font.family_monospace)
